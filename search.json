[{"title":"Android自定义控件小结","url":"/2021/01/14/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%B0%8F%E7%BB%93/","content":"<h3 id=\"绘制文本drawText\"><a href=\"#绘制文本drawText\" class=\"headerlink\" title=\"绘制文本drawText\"></a>绘制文本<code>drawText</code></h3><ul>\n<li><p>计算文本的宽度、高度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> textWidth = paint.measureText(text);</span><br><span class=\"line\">Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class=\"line\"><span class=\"keyword\">float</span> textHeight = fontMetrics.top - fontMetrics.bottom;</span><br></pre></td></tr></table></figure></li>\n<li><p>绘制文本，文本绘制起始点在文本矩形的左下角，注意起始点(floatX, floatY)</p>\n<a id=\"more\"></a>\n\n<p><code>canvas.drawText(text, floatX, floatY, paint);</code> </p>\n</li>\n<li><p>利用path绘制倾斜文本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path path = <span class=\"keyword\">new</span> Path();</span><br><span class=\"line\">path.moveTo(floatX, floatY);<span class=\"comment\">//移到起始点</span></span><br><span class=\"line\">path.lineTo(endX, endY);<span class=\"comment\">// 描路径</span></span><br><span class=\"line\">canvas.drawTextOnPath(text, path, <span class=\"number\">0</span>, <span class=\"number\">0</span>, paint);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"绘制圆角矩形\"><a href=\"#绘制圆角矩形\" class=\"headerlink\" title=\"绘制圆角矩形\"></a>绘制圆角矩形</h3><ul>\n<li><p>直接绘制<code>drawRoundRect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, top, right, bottom);</span><br><span class=\"line\">paint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">canvas.drawRoundRect(rect, floatRX, floatRY, paint);</span><br></pre></td></tr></table></figure></li>\n<li><p>通过裁剪路径<code>clipPath</code>得到，但画布可绘制范围只剩该矩形区域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> r = <span class=\"number\">3</span>; </span><br><span class=\"line\"><span class=\"keyword\">float</span>[] radiusArray = &#123;r,r, r,r, r,r, r,r&#125;;<span class=\"comment\">//对应左、上、右、下四个角的圆角半径</span></span><br><span class=\"line\">Path path = <span class=\"keyword\">new</span> Path();</span><br><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, right, top, bottom);</span><br><span class=\"line\">path.addRoundRect(rect, radiusArray, Path.Direction.CW);</span><br><span class=\"line\">canvas.clipPath(path);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"绘制圆弧drawArc\"><a href=\"#绘制圆弧drawArc\" class=\"headerlink\" title=\"绘制圆弧drawArc\"></a>绘制圆弧<code>drawArc</code></h3><ul>\n<li><p>默认按顺时针方向绘制，设置圆弧所在区域矩形、起始的角度、扫过的角度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, top, right, bottom);</span><br><span class=\"line\">paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">paint.setStrokeCap(Paint.Cap.ROUND);<span class=\"comment\">// 设置描边线为圆角类型</span></span><br><span class=\"line\">canvas.drawArc(rect, startAngle, sweepAngle, <span class=\"keyword\">false</span>, paint);</span><br></pre></td></tr></table></figure></li>\n<li><p>设置圆弧渐变色</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位置数组与色值数组对应</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] GRADIENT_COLORS = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;Color.parseColor(<span class=\"string\">&quot;#F257B0&quot;</span>), Color.parseColor(<span class=\"string\">&quot;#688FFD&quot;</span>)&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 取值范围0-1，0和1为3点钟位置，0.25为6点钟位置，0.5为9点钟位置，0.75为12点位置</span></span><br><span class=\"line\"><span class=\"keyword\">float</span>[] GRADIENT_POSITION = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[]&#123;<span class=\"number\">0.45f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">SweepGradient gradient = <span class=\"keyword\">new</span> SweepGradient(cx, cy, GRADIENT_COLORS, GRADIENT_POSITION);</span><br><span class=\"line\">paint.setShader(gradient);</span><br><span class=\"line\">canvas.drawArc(rect, startAngle, sweepAngle, <span class=\"keyword\">false</span>, paint);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ul>\n<li><p>androd屏幕坐标参考系，水平右方向为x轴正方向，水平左方向为x轴负方向，竖直下方向为y轴正方向，竖直上方向为y轴负方向；</p>\n</li>\n<li><p>画布<code>canvas</code>基本操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">canvas.translate(dx, dy); <span class=\"comment\">// 移动画布中心</span></span><br><span class=\"line\">canvas.rotate(degree); <span class=\"comment\">// 画布旋转角度degree</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<ul>\n<li><p>绘制时使用屏幕的实际尺寸，不能直接使用<code>3px</code>;</p>\n<p><code>int width = context.getResources().getDimensionPixelSize(R.dimen.dp_3px);</code></p>\n</li>\n<li><p>Math类的常用运算</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.toRadians(<span class=\"number\">180</span>);<span class=\"comment\">//角度转弧度</span></span><br><span class=\"line\">Math.toDegrees(pi);<span class=\"comment\">//弧度转角度</span></span><br><span class=\"line\">Math.sin(radians);<span class=\"comment\">//计算三角函数sin值，传入弧度</span></span><br><span class=\"line\">Math.ceil(<span class=\"number\">12.7</span>);<span class=\"comment\">//得13 取天花板值</span></span><br><span class=\"line\">Math.floor(<span class=\"number\">12.7</span>);<span class=\"comment\">//得12 取地板值</span></span><br><span class=\"line\">Math.sqrt(<span class=\"number\">4</span>);<span class=\"comment\">// 求开方</span></span><br><span class=\"line\">Math.pow(x,y);<span class=\"comment\">//求x的y次方</span></span><br><span class=\"line\">Math.round(x);<span class=\"comment\">//求整，四舍五入</span></span><br><span class=\"line\">Math.min(x,y); <span class=\"comment\">//最小值</span></span><br><span class=\"line\">Math.max(x,y); <span class=\"comment\">//最大值\t</span></span><br><span class=\"line\">Math.abs(x);<span class=\"comment\">//绝对值</span></span><br><span class=\"line\">Math.random();<span class=\"comment\">// 返回0-1随机数</span></span><br></pre></td></tr></table></figure></li>\n<li><p>浮点数保持精度计算<code>BigDecimal</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal bigDecimal = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;3.14159&quot;</span>);</span><br><span class=\"line\">bigDecimal.setScale(<span class=\"number\">2</span>, BigDecimal.ROUND_DOWN);<span class=\"comment\">// 取小数点后2位</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>动画动态取值<code>ValueAnimator</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(startValue, endValue);</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">3000</span>);<span class=\"comment\">// 设置动画持续时长</span></span><br><span class=\"line\">animator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 在duration时长内，返回startValue-endValue区间的值,根据不同的值重绘界面，形成动态</span></span><br><span class=\"line\">  \t\t<span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>) valueAnimator.getAnimatedValue();</span><br><span class=\"line\">    \tLog.d(TAG, <span class=\"string\">&quot;animator value:&quot;</span> + value);</span><br><span class=\"line\">                    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n","categories":["工作小结"],"tags":["android","自定义控件"]},{"title":"通过CentOS的Docker部署calibre-web搭建私人电子图书馆","url":"/2021/01/13/docker-web%E6%90%AD%E5%BB%BA/","content":"<h3 id=\"前期准备工作\"><a href=\"#前期准备工作\" class=\"headerlink\" title=\"前期准备工作\"></a>前期准备工作</h3><ul>\n<li><p>本地电脑安装Calibre, windows|Mac|Linux各种版本都有，建立本地的书库目录books用于存放电子书及metadata数据库，我这里用的是windows；</p>\n</li>\n<li><p>在windows是安装好与服务器连接的软件Xshell和用于传输文件的Sftp，或是其它同样功能的软件也可以</p>\n</li>\n<li><p>准备好服务器，我这里是选用的centos7，有NAS的也一样可以下载docker进行部署</p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"搭建calibre-web应用\"><a href=\"#搭建calibre-web应用\" class=\"headerlink\" title=\"搭建calibre-web应用\"></a>搭建calibre-web应用</h3><ul>\n<li><p>首先通过<code>docker -v</code> 检查是否安装了docker, 如果未安装通过以下命令安装： <code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code> 是否需要使用Aliyun镜像看个人情况。</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/pull_error.png\" alt=\"docker_version\" style=\"zoom:100%;\">  \n\n\n\n</li>\n</ul>\n<ul>\n<li><p>使用docker命令从github拉取calibre-web应用，github上下载量较高有以下3个：linuxserver/calibre-web，technosoft2000/calibre-web，janeczku/calibre-web, 我用的是第1个，有不少同学说linuxserver/calibre-web不能进行格式转换，但通过正常配置是可以正常转换格式的；<code>docker pull linuxserver/calibre-web</code> 拉取应用，</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/install_calibre.png\" alt=\"pull_error\" style=\"zoom:100%;\">  \n\n\n\n</li>\n</ul>\n<p>  如果报错<code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code> 说明docker应用进程没有正常启动 ，需要先手动启动<code>systemctl restart docker.service</code>，再拉取应用。</p>\n<ul>\n<li><p>在docker中创建calibre-web应用：</p>\n<p><code>docker create \\    --name=calibre-web \\    -e PUID=1000 \\    -e PGID=1000 \\    -e TZ=Asia/Shanghai \\ -p 8083:8083 \\    -e DOCKER_MODS=linuxserver/calibre-web:calibre \\ -v /data/calibre/config:/config \\    -v /data/calibre/books:/books \\ --restart unless-stopped \\    linuxserver/calibre-web</code></p>\n<p>关键参数说明：<code>--name=calibre-web</code>应用名称， <code>-p 8083:8083</code> 端口映射，配置成功后通过该 端口访问，记得防火墙中要放开该端口，否则无法访问 ，<code>-e DOCKER_MODS=linuxserver/calibre-web:calibre</code>是否需要支持格式功能，仅x86_64的cpu支持（但还需要在calibre-web中进行配置），<code>-v /data/calibre/config:/config</code>服务器本地与calibre应用配置文件夹映射关系，用于存放用户数据等，<code>-v /data/calibre/books:/books</code>服务器本地与calibre书籍目录映射关系。</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/mkdir.png\" alt=\"install_calibre\" style=\"zoom:100%;\">\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>在centos中使用mkdir命令创建目录/data/calibre/books和/data/calibre/config，并授予文件夹读写权限</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/docker_version.png\" alt=\"mkdir\" style=\"zoom:100%;\">\n</li>\n<li><p>在windows下Calibre本地书库中books，使用xftp将本地windows书库中的所有电子书导入到centos服务器<code>/data/calibre/books</code> 目录下，注意：books目录下的除了所有书籍文件夹上传外，metadata.db数据库也一并上传到centos7中的/data/calibre/books目录下，不然会报“数据库路径无效，请输入正确的路径”</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/base_config.png\" alt=\"tanslate_books\" style=\"zoom:100%;\">\n</li>\n<li><p>在服务中开启calibre-web应用<code>docker start calibre-web</code>, 通过浏览器打开<code>http://host:8083</code>进入calibre-web，在calibre书库配置中填写<code>/books</code>即映射到centos服务器中的<code>/data/calibre/books</code>目录下；如果提示“数据库路径无效，请输入正确的路径”，在本地windows中Calibre软件重新创建一个书库文件夹，并将其文件夹下的metadata.db文件单独上传上述centos服务器路径；并对文件夹授予读写权限<code> chmod -R 777 /data/calibre/</code></p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/login.png\" alt=\"base_config\" style=\"zoom:100%;\">\n</li>\n<li><p>使用管理员账号admin/admin123登录calibre-web，并在设置中心修改为语言为中文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/translate_books.png\" alt=\"login\" style=\"zoom:100%;\">\n</li>\n<li><p>登录成功，界面默认为英文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/lang_config.png\" alt=\"login_success\" style=\"zoom:75%;\">\n</li>\n<li><p>点击用户名admin，在Language下修改语言为中文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert_router.png\" alt=\"lang_config\" style=\"zoom:100%;\">\n</li>\n<li><p>修改成功的中文界面</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/add_permision.png\" alt=\"lang_cn\" style=\"zoom:100%;\">\n\n\n\n</li>\n</ul>\n<h3 id=\"Calibre-web功能进阶：格式转换-amp-邮件转发至Kindle\"><a href=\"#Calibre-web功能进阶：格式转换-amp-邮件转发至Kindle\" class=\"headerlink\" title=\"Calibre-web功能进阶：格式转换 &amp;邮件转发至Kindle\"></a>Calibre-web功能进阶：格式转换 &amp;邮件转发至Kindle</h3><ul>\n<li><p>登录管理员账号找到 管理权限 - 配置 - 编辑基本配置 - 扩展程序配置，在“Calibre电子书转换路径”栏中填写 <code>/usr/bin/ebook-convert</code> 在Unrar程序路径填<code>/usr/bin/unrar</code>，</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/lang_cn.png\" alt=\"convert_router\"></p>\n<p>注意在容器创建时添加了参数<code>-e DOCKER_MODS=linuxserver/calibre-web:calibre</code> 才能支持格式转换，另外，还需要在centos下新建目录并在路径下添加权限、添加权限、添加权限，重要的事说3遍，<code>chmod -R 777 /usr/bin/ebook-convert</code> </p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert-book.png\" alt=\"add_permision\"></p>\n</li>\n<li><p>在书籍编辑界面对书籍进行格式转换，在任务列表中可以查看转换进度，如果没有给目录<code>/usr/bin/ebook-convert</code>添加权限，在转换进度的最后时刻会提示失败。</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert-success.png\" alt=\"convert-book\"></p>\n<p>转换成功：</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/config_email.png\" alt=\"convert-success\"></p>\n</li>\n<li><p>设置将电子书通过邮件发送到kindle邮箱，以163为例，首行登录到邮箱首页，找到设置 - POP3/SMTP/IMAP</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/smtp_code.png\" alt=\"login_email\"></p>\n<p>然后打开IMAP/SMTP服务，接着新增授权码，记住该码</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/login_email.png\" alt=\"smtp_code\"></p>\n</li>\n<li><p>登录管理员账号找到 管理权限 - SMTP邮件服务器配置 - 编辑邮件服务器配置，按下图填写信息，其中SMTP密码就是上一步中从163邮箱中获取到的授权密码，保存，在查看书籍信息时右上角就有转发到邮件的选项了，但是为了让你的kindle可以正常接收到电子书邮件，还需要登录你的亚马逊账户，在设置中添加可依赖的发件邮箱，即上面的163邮箱。</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/config_email.png\" alt=\"config_email\"></p>\n</li>\n</ul>\n","categories":["瞎折腾"],"tags":["centos","docker","calibre-web","电子书"]},{"title":"recyclerView使用小结(一)","url":"/2021/01/20/recyclerview_use1/","content":"<h3 id=\"recyclerView-Adapter主要方法及执行顺序\"><a href=\"#recyclerView-Adapter主要方法及执行顺序\" class=\"headerlink\" title=\"recyclerView.Adapter主要方法及执行顺序\"></a>recyclerView.Adapter主要方法及执行顺序</h3><ul>\n<li><p>recyclerview适配器Adapter中主要方法有构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法；</p>\n</li>\n<li><p>主要的方法的执行顺序为：构造方法 –&gt; getItemViewType –&gt; onCreateViewHolder –&gt; onBindViewHolder</p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\"><a href=\"#在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\" class=\"headerlink\" title=\"在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\"></a>在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同</h3><h4 id=\"针对不同的数据结构，先创建数据的基类IBaseData-定义不的类型常量如TYPE-FIRST-1及默认类型TYPE-NULL-1，对外暴露获取类型的方法与获取数据T的方法；\"><a href=\"#针对不同的数据结构，先创建数据的基类IBaseData-定义不的类型常量如TYPE-FIRST-1及默认类型TYPE-NULL-1，对外暴露获取类型的方法与获取数据T的方法；\" class=\"headerlink\" title=\"针对不同的数据结构，先创建数据的基类IBaseData,定义不的类型常量如TYPE_FIRST=1及默认类型TYPE_NULL=-1，对外暴露获取类型的方法与获取数据T的方法；\"></a>针对不同的数据结构，先创建数据的基类<code>IBaseData</code>,定义不的类型常量如TYPE_FIRST=1及默认类型TYPE_NULL=-1，对外暴露获取类型的方法与获取数据T的方法；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBaseData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_NULL = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_FIRST = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_SECOND = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEntity</span><span class=\"params\">(T data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getEntity</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\"><a href=\"#新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\" class=\"headerlink\" title=\"新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\"></a>新建类<code>BaseDataImpl</code>实现之前创建的数据基类<code>IBaseData</code>，通过构造方法传不同的数据类型的实例bean；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseDataImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBaseData</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Object object;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseDataImpl</span><span class=\"params\">(Object object, <span class=\"keyword\">int</span> type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEntity</span><span class=\"params\">(Object data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getEntity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder-IBaseData-data-int-position-来调用adapter的根方法onBindViewHolder-BaseViewHolder-holder-int-position-，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\"><a href=\"#针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder-IBaseData-data-int-position-来调用adapter的根方法onBindViewHolder-BaseViewHolder-holder-int-position-，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\" class=\"headerlink\" title=\"针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder(IBaseData data, int position)来调用adapter的根方法onBindViewHolder(BaseViewHolder holder, int position)，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\"></a>针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过<code>findViewById</code>去查找使用子控件；关键方法是<code>bindViewHolder(IBaseData data, int position)</code>来调用adapter的根方法<code>onBindViewHolder(BaseViewHolder holder, int position)</code>，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseViewHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(inflateView(parent,layoutId));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> View <span class=\"title\">inflateView</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> View <span class=\"title\">findViewById</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> itemView.findViewById(viewId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">bindViewHolder</span><span class=\"params\">(IBaseData data, <span class=\"keyword\">int</span> position)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List-lt-BaseDataImpl-gt-界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder\"><a href=\"#新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List-lt-BaseDataImpl-gt-界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder\" class=\"headerlink\" title=\"新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List&lt;BaseDataImpl&gt;界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder;\"></a>新建recyclerView的adapter类<code>MyAdapter</code>，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以<code>List&lt;BaseDataImpl&gt;</code>界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder;</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">BaseViewHolder</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;BaseDataImpl&gt; mData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyAdapter</span><span class=\"params\">(List&lt;BaseDataImpl&gt; mData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mData = mData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(List&lt;BaseDataImpl&gt; data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mData = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BaseViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (IBaseData.TYPE_FIRST == viewType) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LeftTextViewHolder(parent, R.layout.item_left_text);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (IBaseData.TYPE_SECOND == viewType) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RightTextViewHolder(parent, R.layout.item_right_text);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(BaseViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</span><br><span class=\"line\">        holder.bindViewHolder(mData.get(position), position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemViewType</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mData.get(position) == <span class=\"keyword\">null</span> ? IBaseData.TYPE_NULL: mData.get(position).getType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mData == <span class=\"keyword\">null</span>? <span class=\"number\">0</span>: mData.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item-left-text如下，RightData与LeftData数据结构一样，item-right-text布局靠右对齐，item-left-text靠左对齐；\"><a href=\"#其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item-left-text如下，RightData与LeftData数据结构一样，item-right-text布局靠右对齐，item-left-text靠左对齐；\" class=\"headerlink\" title=\"其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item_left_text如下，RightData与LeftData数据结构一样，item_right_text布局靠右对齐，item_left_text靠左对齐；\"></a>其中<code>LeftTextViewHolder</code>是<code>BaseViewHolder</code>的实现类，对应的数据结构<code>LeftData</code>与界面布局<code>item_left_text</code>如下，<code>RightData</code>与<code>LeftData</code>数据结构一样，<code>item_right_text</code>布局靠右对齐，<code>item_left_text</code>靠左对齐；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeftData</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String subTitle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LeftData</span><span class=\"params\">(String title, String subTitle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subTitle = subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSubTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSubTitle</span><span class=\"params\">(String subTitle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subTitle = subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/tv_title&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_alignParentLeft=&quot;true&quot;</span><br><span class=\"line\">        android:layout_alignParentTop=&quot;true&quot;</span><br><span class=\"line\">        android:layout_marginLeft=&quot;15dp&quot;</span><br><span class=\"line\">        android:paddingTop=&quot;15dp&quot;</span><br><span class=\"line\">        android:text=&quot;我是标题&quot;</span><br><span class=\"line\">        android:textColor=&quot;#000000&quot;</span><br><span class=\"line\">        android:textSize=&quot;16sp&quot; /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/tv_subTitle&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@id/tv_title&quot;</span><br><span class=\"line\">        android:layout_marginLeft=&quot;15dp&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;8dp&quot;</span><br><span class=\"line\">        android:paddingBottom=&quot;15dp&quot;</span><br><span class=\"line\">        android:text=&quot;我是子标题&quot;</span><br><span class=\"line\">        android:textColor=&quot;#99000000&quot;</span><br><span class=\"line\">        android:textSize=&quot;12sp&quot; /&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\"><a href=\"#在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\" class=\"headerlink\" title=\"在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\"></a>在界面类<code>RecyclerViewActivity</code>中引中新建的adapter类，并传入不同类型的数据，如<code>LeftData</code>封装进<code>BaseDataImpl</code>统一由<code>MyAdapter</code>处理</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecyclerViewActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_recyclerview);</span><br><span class=\"line\"></span><br><span class=\"line\">        RecyclerView rvContent = (RecyclerView) findViewById(R.id.rv_content);</span><br><span class=\"line\">        rvContent.setLayoutManager(<span class=\"keyword\">new</span> LinearLayoutManager(<span class=\"keyword\">this</span>, LinearLayoutManager.VERTICAL, <span class=\"keyword\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        LeftData leftData = <span class=\"keyword\">new</span> LeftData(<span class=\"string\">&quot;我是主标题我是主标题&quot;</span>,<span class=\"string\">&quot;我是小标题我是小标题我是小标题&quot;</span>);</span><br><span class=\"line\">        BaseDataImpl leftImpl = <span class=\"keyword\">new</span> BaseDataImpl(leftData, IBaseData.TYPE_FIRST);</span><br><span class=\"line\"></span><br><span class=\"line\">        RightData rightData = <span class=\"keyword\">new</span> RightData(<span class=\"string\">&quot;我是主标题我是主标题&quot;</span>,<span class=\"string\">&quot;我是小标题我是小标题我是小标题&quot;</span>);</span><br><span class=\"line\">        BaseDataImpl rightImpl = <span class=\"keyword\">new</span> BaseDataImpl(rightData, IBaseData.TYPE_SECOND);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;BaseDataImpl&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        dataList.add(leftImpl);</span><br><span class=\"line\">        dataList.add(rightImpl);</span><br><span class=\"line\"></span><br><span class=\"line\">        MyAdapter myAdapter = <span class=\"keyword\">new</span> MyAdapter(dataList);</span><br><span class=\"line\">        rvContent.setAdapter(myAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\"><a href=\"#界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\" class=\"headerlink\" title=\"界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\"></a>界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。</h4><p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/2021-01-26-121132.png\" alt=\"2021-01-26-121132\"></p>\n","categories":["工作小结"],"tags":["android","recyclerview"]},{"title":"二叉树遍历Tree Traversals Again","url":"/2021/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86Tree-Traversals-Again/","content":"<h4 id=\"03-树3-Tree-Traversals-Again\"><a href=\"#03-树3-Tree-Traversals-Again\" class=\"headerlink\" title=\"03-树3 Tree Traversals Again\"></a><strong>03-树3 Tree Traversals Again</strong></h4><p>​    An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/20151020162946653.png\" alt=\"20151020162946653\"></p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<h5 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">Push <span class=\"number\">1</span></span><br><span class=\"line\">Push <span class=\"number\">2</span></span><br><span class=\"line\">Push <span class=\"number\">3</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br><span class=\"line\">Push <span class=\"number\">4</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br><span class=\"line\">Push <span class=\"number\">5</span></span><br><span class=\"line\">Push <span class=\"number\">6</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">2</span> <span class=\"number\">6</span> <span class=\"number\">5</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><p>​    从堆栈实现二叉树非递归遍历算法可知，入栈操作是先序遍历的顺序，而出栈操作则是中序遍历操作的顺序，需要输出后序遍历的顺序；所以需要根据push和pop构造出先序数组和中序数组，再利用递归算法依次找到根结点左右两边各元素的顺序。</p>\n<h5 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 50</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *in, *pre, *post, number;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PtrToSNode <span class=\"title\">CreateStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    PtrToSNode temp;</span><br><span class=\"line\">    temp = (PtrToSNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    temp-&gt;top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(PtrToSNode s, <span class=\"keyword\">int</span> item)</span> </span>&#123;</span><br><span class=\"line\">    s-&gt;data[++(s-&gt;top)] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Pop</span><span class=\"params\">(PtrToSNode s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s-&gt;data[(s-&gt;top)--];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestroyStack</span><span class=\"params\">(PtrToSNode s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据输入数据创建先序数组pre和中序数组in</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Input</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, n, value, indexPush = <span class=\"number\">0</span>, indexPop = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> temp[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建堆栈Stack</span></span><br><span class=\"line\">    PtrToSNode Stack = CreateStack();</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取共有多少数字number</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    n = number * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3.根据输入的number创建pre,in,post数组</span></span><br><span class=\"line\">    in = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    pre = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    post = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    <span class=\"comment\">// 4.根据输入的数据，读取push或pop操作，小于number*2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5.读取字符串temp</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, temp);</span><br><span class=\"line\">        <span class=\"comment\">// 6.字符串是否包含字符h</span></span><br><span class=\"line\">        s = <span class=\"built_in\">strchr</span>(temp, <span class=\"string\">&#x27;h&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果包含，则继续读取数值value</span></span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;value);</span><br><span class=\"line\">            <span class=\"comment\">// 8.将读取到数值存入数组pre，并压入堆栈Stack</span></span><br><span class=\"line\">            pre[indexPush] = value;</span><br><span class=\"line\">            Push(Stack, value);</span><br><span class=\"line\">            indexPush++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 9.如果不包含字符h,则弹栈，将值存入数组in</span></span><br><span class=\"line\">            in[indexPop] = Pop(Stack);</span><br><span class=\"line\">            indexPop++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 10.释放堆栈Stack</span></span><br><span class=\"line\">    DestroyStack(Stack);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据先序、中序获取后序数组post</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetPost</span><span class=\"params\">(<span class=\"keyword\">int</span> preL, <span class=\"keyword\">int</span> inL, <span class=\"keyword\">int</span> postL, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果在数组外，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果数组最后只有一个元素时，直接将先序值赋值给后序对应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        post[postL] = pre[preL];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root, i, lenL, lenR;</span><br><span class=\"line\">    <span class=\"comment\">// 3.数组长度大于1时，将先序pre的第1个元素即为根结点</span></span><br><span class=\"line\">    root = pre[preL];</span><br><span class=\"line\">    <span class=\"comment\">// 4.将根结点的值赋值给post数组的最末位</span></span><br><span class=\"line\">    post[postL + len - <span class=\"number\">1</span>] = root;</span><br><span class=\"line\">    <span class=\"comment\">// 5.遍历找到根结点root在中序数组in中的位置i</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (in[inL + i] == root)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 6.根结点root的左子树部分长度即为i, 右子树长度为len-i-1（根结点）</span></span><br><span class=\"line\">    lenL = i;</span><br><span class=\"line\">    lenR = len - lenL - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 7.递归求左子树部分, 先序指针右移1位, 数组为左子树部分lenL</span></span><br><span class=\"line\">    GetPost(preL + <span class=\"number\">1</span>, inL, postL, lenL);</span><br><span class=\"line\">    <span class=\"comment\">// 8.递归求右子树部分, 先序、中序、后序指针移至根结点右边，数组长度不右子树部分lenR</span></span><br><span class=\"line\">    GetPost(preL + lenL + <span class=\"number\">1</span>, inL + lenL + <span class=\"number\">1</span>, postL + lenL, lenR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printPost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; number; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == number - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, post[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, post[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Input();</span><br><span class=\"line\">    GetPost(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, number);</span><br><span class=\"line\">    printPost();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["PTA"],"tags":["树","树习题"]},{"title":"图遍历Saving James Bond - Easy Version","url":"/2021/07/24/%E5%9B%BE%E9%81%8D%E5%8E%86Saving-James-Bond-Easy-Version/","content":"<h4 id=\"06-图2-Saving-James-Bond-Easy-Version-25-分\"><a href=\"#06-图2-Saving-James-Bond-Easy-Version-25-分\" class=\"headerlink\" title=\"06-图2 Saving James Bond - Easy Version (25 分)\"></a><strong>06-图2 Saving James Bond - Easy Version (25 分)</strong></h4><p>​    This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/20171119150253795.png\" alt=\"20171119150253795\"></p>\n<p>​    Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, print in a line “Yes” if James can escape, or “No” if not.</p>\n<h5 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input 1:\"></a>Sample Input 1:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">14</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"number\">25</span> <span class=\"number\">-15</span></span><br><span class=\"line\"><span class=\"number\">-25</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">29</span> <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"number\">-35</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">27</span> <span class=\"number\">-29</span></span><br><span class=\"line\"><span class=\"number\">-8</span> <span class=\"number\">-28</span></span><br><span class=\"line\"><span class=\"number\">-20</span> <span class=\"number\">-35</span></span><br><span class=\"line\"><span class=\"number\">-25</span> <span class=\"number\">-20</span></span><br><span class=\"line\"><span class=\"number\">-13</span> <span class=\"number\">29</span></span><br><span class=\"line\"><span class=\"number\">-30</span> <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"number\">-35</span> <span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output 1:\"></a>Sample Output 1:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Yes</span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input 2:\"></a>Sample Input 2:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">-12</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">-12</span> <span class=\"number\">-12</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">-12</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output 2:\"></a>Sample Output 2:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">No</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><ol>\n<li>根据输入的鳄鱼条数N创建图中的坐标点，用结构体数组表示；</li>\n<li>根据当前坐标是否可以直接跳到安全的岸边IsSafe；</li>\n<li>遍历数组所有的点，判断哪些可以完成第一步跳跃FirstJump；</li>\n<li>完成第一跳后继续深度搜索DFS哪些点可以进行下一跳CanJump；</li>\n<li>输出是否存在安全跳到岸边的可能。</li>\n</ol>\n<h5 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码:\"></a>编码:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DIA 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIDE 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsSafe</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FirstJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index1, <span class=\"keyword\">int</span> index2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.恶鱼所在坐标数组A，最大为100</span></span><br><span class=\"line\"><span class=\"comment\">// 2.标记数组B，是否是访问过</span></span><br><span class=\"line\"><span class=\"comment\">// 3.恶鱼的条数N, 以及007跳跃的距离D</span></span><br><span class=\"line\"><span class=\"comment\">// 4.池塘边长SIDE为100，中间小岛半径DIA15</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125; A[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> B[MAXN], N, D;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取恶鱼的条数，以及007跳跃的距离D</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;N, &amp;D);</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取各条恶鱼的坐标，存储在数组A中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;A[i].x, &amp;A[i].y);</span><br><span class=\"line\">    <span class=\"comment\">// 3.判断是否可以跳到岸边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsSafe(<span class=\"number\">-1</span>))</span><br><span class=\"line\">        flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4.如不能，则遍历恶鱼寻找可以第一步跳的恶鱼</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!B[i] &amp;&amp; FirstJump(i)) &#123;</span><br><span class=\"line\">                B[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 5.如果完成第一跳，继续深度搜索DFS</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DFS(i))</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以跳到岸边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsSafe</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.是否为第一跳-1，小岛半径 + 跳跃距离 &gt; 边长</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">double</span>) DIA / <span class=\"number\">2</span> + D &gt;= (<span class=\"keyword\">double</span>) SIDE / <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非第一跳，当前坐标x或y+跳跃距离大于边长，说明成功</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = A[index].x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = A[index].y;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">abs</span>(x) + D &gt;= SIDE / <span class=\"number\">2</span>) || (<span class=\"built_in\">abs</span>(y) + D &gt;= SIDE / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以第一跳</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FirstJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.坐标x,y到圆心的距离distance</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> distance = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">pow</span>(A[index].x, <span class=\"number\">2</span>) + <span class=\"built_in\">pow</span>(A[index].y, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果跳跃距离 + 边长 &gt;= 半径distance，则为真</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (D + (<span class=\"keyword\">double</span>) DIA / <span class=\"number\">2</span> &gt;= distance);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以下一跳</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index1, <span class=\"keyword\">int</span> index2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x1 = A[index1].x, y1 = A[index1].y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x2 = A[index2].x, y2 = A[index2].y;</span><br><span class=\"line\">    <span class=\"comment\">// 1.取index1,index2两点间的距离distance</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> distance = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">pow</span>(x1 - x2, <span class=\"number\">2</span>) + <span class=\"built_in\">pow</span>(y1 - y2, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果点距distance小于等于可跳跃的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> D &gt;= distance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深度搜索index</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断是否可以跳到岸边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsSafe(index))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历数组中所有的点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果点i未被访问过，且点i可以跳跃到，则继续下一跳DFS递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!B[i] &amp;&amp; CanJump(i, index)) &#123;</span><br><span class=\"line\">            B[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DFS(i))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["PTA"],"tags":["图","图习题"]},{"title":"树结构_二叉搜索树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"<h4 id=\"二叉搜索树的结构与其操作\"><a href=\"#二叉搜索树的结构与其操作\" class=\"headerlink\" title=\"二叉搜索树的结构与其操作\"></a>二叉搜索树的结构与其操作</h4><h5 id=\"结构-BinNode-BinTree-Position\"><a href=\"#结构-BinNode-BinTree-Position\" class=\"headerlink\" title=\"结构 BinNode - BinTree - Position\"></a>结构 BinNode - BinTree - Position</h5><ol>\n<li>树结点数据Data</li>\n<li>左子树Left</li>\n<li>右子树Right</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"查找-递归\"><a href=\"#查找-递归\" class=\"headerlink\" title=\"查找 - 递归\"></a>查找 - 递归</h5><ol>\n<li>判空BST</li>\n<li>如果元素X大于结点数据，向右递归</li>\n<li>如果元素X小于结点数据，向左递归</li>\n<li>如果相等，直接返回</li>\n</ol>\n<h5 id=\"查找-非递归\"><a href=\"#查找-非递归\" class=\"headerlink\" title=\"查找 - 非递归\"></a>查找 - 非递归</h5><ol>\n<li>循环遍历二叉树BST</li>\n<li>如果结点数据大于元素X，BST指向左子树</li>\n<li>如果结点数据小于元素X，BST指向右子树</li>\n<li>如果相等，跳出并返回BST</li>\n</ol>\n<h5 id=\"找最小值\"><a href=\"#找最小值\" class=\"headerlink\" title=\"找最小值\"></a>找最小值</h5><ol>\n<li>如果二叉树BST不为空</li>\n<li>树BST的左子树不为空则一直向左查找，直到最左树</li>\n</ol>\n<h5 id=\"找最大值\"><a href=\"#找最大值\" class=\"headerlink\" title=\"找最大值\"></a>找最大值</h5><ol>\n<li>如果二叉树BST不为空</li>\n<li>树BST的右子树不为空则一直向右查找，直到最右树</li>\n</ol>\n<h5 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h5><ol>\n<li>如果BST树为空，说明找到插入位置，</li>\n<li>为BST申请结点空间，将插入值X赋值给结点，并初始化左、右子树为NULL</li>\n<li>如果插入值X小于结点元素，递归向左子树插入</li>\n<li>如果插入值X大于结点元素，递归向右子树插入</li>\n</ol>\n<h5 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h5><ol>\n<li>判断树BST是否为空</li>\n<li>如果待删元素X小于结点值，递归向左删除元素</li>\n<li>如果待删元素X大于结点值，递归向右删除元素</li>\n<li>找到了要删除的元素,且该元素有两个孩子</li>\n<li>从左子树中找到最大子树填充删除结点，或是从右子树中找到最小子树填充</li>\n<li>将找到的最大结点或最小结点的值覆盖到当前待结点</li>\n<li>从右子树中删除最小元素结点，或是在左子树中删除最大元素结点</li>\n<li>如果只有右孩子或无结点, 当前结点被右子树覆盖</li>\n<li>如果只有左孩子，当前结点被左子树覆盖</li>\n<li>释放当前结点</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinNode</span> *<span class=\"title\">BinTree</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二叉搜索树结构</span></span><br><span class=\"line\"><span class=\"comment\"> * 查找+找大+找小+插入+删除（递归+循环）5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.树结点数据</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.左子树</span></span><br><span class=\"line\">    BinTree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.右子树</span></span><br><span class=\"line\">    BinTree Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> BinTree Position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找 - 递归</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">Find</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果元素X大于结点数据，向右递归</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">        Find(BST-&gt;Left, X);</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果元素X小于结点数据，向左递归</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">        Find(BST-&gt;Right, X);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.如果相等，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找 - 非递归</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindX</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.循环遍历二叉树BST</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果结点数据大于元素X，BST指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Left;</span><br><span class=\"line\">            <span class=\"comment\">//3.如果结点数据小于元素X，BST指向右子树</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Right;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//4.如果相等，跳出并返回BST</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找最小值</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindMin</span><span class=\"params\">(BinTree BST)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树BST不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.树BST的左子树不为空则一直向左查找，直到最左树</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (BST-&gt;Left) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找最大值</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindMax</span><span class=\"params\">(BinTree BST)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树BST不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.树BST的右子树不为空则一直向右查找，直到最右树</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (BST-&gt;Right) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入结点</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">Insert</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果BST树为空，说明找到插入位置，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.为BST申请结点空间，将插入值X赋值给结点，并初始化左、右子树为NULL</span></span><br><span class=\"line\">        BST = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct BinNode));</span><br><span class=\"line\">        BST-&gt;Data = X;</span><br><span class=\"line\">        BST-&gt;Left = BST-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果插入值X小于结点元素，递归向左子树插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">            BST-&gt;Left = Insert(BST-&gt;Left, X);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.如果插入值X大于结点元素，递归向右子树插入</span></span><br><span class=\"line\">            BST-&gt;Right = Insert(BST-&gt;Right, X);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除结点</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">Delete</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position Tmp;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断树BST是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Not Found\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果待删元素X小于结点值，递归向左删除元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (X &lt; BST-&gt;Data) &#123;</span><br><span class=\"line\">            BST-&gt;Left = Delete(BST-&gt;Left, X);</span><br><span class=\"line\">            <span class=\"comment\">// 3.如果待删元素X大于结点值，递归向右删除元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &gt; BST-&gt;Data) &#123;</span><br><span class=\"line\">            BST-&gt;Right = Delete(BST-&gt;Right, X);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.找到了要删除的元素,且该元素有两个孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 分两步走，先删替换该结点(有2子)的值，再删除右最小或左最大的结点</span></span><br><span class=\"line\">                <span class=\"comment\">// 5.从左子树中找到最大子树填充删除结点，或是从右子树中找到最小子树填充</span></span><br><span class=\"line\">                Tmp = FindMin(BST-&gt;Right);</span><br><span class=\"line\">                <span class=\"comment\">// 6.将找到的最大结点或最小结点的值覆盖到当前待结点</span></span><br><span class=\"line\">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class=\"line\">                <span class=\"comment\">// 7.从右子树中删除最小元素结点，或是在左子树中删除最大元素结点</span></span><br><span class=\"line\">                BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Tmp = BST;</span><br><span class=\"line\">                <span class=\"comment\">// 8.如果只有右孩子或无结点, 当前结点被右子树覆盖</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!BST-&gt;Left) &#123;</span><br><span class=\"line\">                    BST = BST-&gt;Right;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 9.如果只有左孩子，当前结点被左子树覆盖</span></span><br><span class=\"line\">                    BST = BST-&gt;Left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 10.释放当前结点</span></span><br><span class=\"line\">                <span class=\"built_in\">free</span>(Tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_二叉树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h4 id=\"树结构-二叉树的结构及其操作\"><a href=\"#树结构-二叉树的结构及其操作\" class=\"headerlink\" title=\"树结构 - 二叉树的结构及其操作\"></a>树结构 - 二叉树的结构及其操作</h4><h5 id=\"结构-TNode-PtrToTNode-BinTree\"><a href=\"#结构-TNode-PtrToTNode-BinTree\" class=\"headerlink\" title=\"结构 TNode - PtrToTNode - BinTree\"></a>结构 TNode - PtrToTNode - BinTree</h5><ol>\n<li>结点数据Data</li>\n<li>当前结点的左子树</li>\n<li>当前结点的右子树</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请树TNode空间</li>\n<li>初始化树的左、右孩子为NULL</li>\n</ol>\n<h5 id=\"先序遍历-根-左-右\"><a href=\"#先序遍历-根-左-右\" class=\"headerlink\" title=\"先序遍历 (根 - 左 - 右)\"></a>先序遍历 (根 - 左 - 右)</h5><ol>\n<li>如果树不为空</li>\n<li>访问当前树的数据</li>\n<li>一路递归向左子树走</li>\n<li>再转身树的右子树递归</li>\n</ol>\n<h5 id=\"中序遍历-左-根-右\"><a href=\"#中序遍历-左-根-右\" class=\"headerlink\" title=\"中序遍历 (左 - 根 - 右)\"></a>中序遍历 (左 - 根 - 右)</h5><ol>\n<li>如果树不为空</li>\n<li>一路递归向左子树走</li>\n<li>访问当前树的数据</li>\n<li>再转身树的右子树递归</li>\n</ol>\n<h5 id=\"后序遍历-左-右-根\"><a href=\"#后序遍历-左-右-根\" class=\"headerlink\" title=\"后序遍历 (左 - 右 - 根)\"></a>后序遍历 (左 - 右 - 根)</h5><ol>\n<li>如果树不为空</li>\n<li>一路递归向左子树走</li>\n<li>再转身树的右子树递归</li>\n<li>访问当前树的数据</li>\n</ol>\n<h5 id=\"非递归遍历-堆栈实现中序遍历\"><a href=\"#非递归遍历-堆栈实现中序遍历\" class=\"headerlink\" title=\"非递归遍历 - 堆栈实现中序遍历\"></a>非递归遍历 - 堆栈实现中序遍历</h5><ol>\n<li>创建堆栈S</li>\n<li>树T不为空，或栈S不为空，就一直循环</li>\n<li>遍历左子树，并将沿途结点压入栈</li>\n<li>将最深层的左树结点从堆栈中弹出T，并访问</li>\n<li>转向访问该结点T的右子树</li>\n</ol>\n<h5 id=\"非递归遍历-层序遍历\"><a href=\"#非递归遍历-层序遍历\" class=\"headerlink\" title=\"非递归遍历 - 层序遍历\"></a>非递归遍历 - 层序遍历</h5><ol>\n<li>判空BT</li>\n<li>创建空队列</li>\n<li>将根结点加到队列中</li>\n<li>遍历队列Q至空</li>\n<li>从队列中取出一个元素结点，访问打印</li>\n<li>如果结点左子树不为空，将结点的左子树添加到队列中</li>\n<li>如果结点右子树不为空，将结点的右子树添加到队列中</li>\n</ol>\n<h5 id=\"求所有叶子结点（基于先序遍历）\"><a href=\"#求所有叶子结点（基于先序遍历）\" class=\"headerlink\" title=\"求所有叶子结点（基于先序遍历）\"></a>求所有叶子结点（基于先序遍历）</h5><ol>\n<li>如果二叉树不为空</li>\n<li>判断是否有子孩子,无则是叶子结点</li>\n<li>递归向左子树</li>\n<li>递归向右子树</li>\n</ol>\n<h5 id=\"求二叉树的高度\"><a href=\"#求二叉树的高度\" class=\"headerlink\" title=\"求二叉树的高度\"></a>求二叉树的高度</h5><ol>\n<li>判空NULL</li>\n<li>递归求左子树的高度HL</li>\n<li>递归求右子树的高度HR</li>\n<li>返回较大者MaxH，+1指包含当前层</li>\n</ol>\n<h5 id=\"根据层序遍历生成二叉树\"><a href=\"#根据层序遍历生成二叉树\" class=\"headerlink\" title=\"根据层序遍历生成二叉树\"></a>根据层序遍历生成二叉树</h5><ol>\n<li>创建队列Q</li>\n<li>读入根结点数据</li>\n<li>动态申请空结点BT，赋值给结点并初始化左右子树为NULL</li>\n<li>将根结点BT加入队列</li>\n<li>如果队列不为空，遍历队列</li>\n<li>Q出列得到T</li>\n<li>读取左子树数据</li>\n<li>如果输入的数据不为空，则插入T的左子树，并加入队列Q</li>\n<li>读取右子树数据</li>\n<li>如果输入的数据不为空，则插入T的右子树，并加入队列Q</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NoInfo 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> *<span class=\"title\">PtrToTNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToTNode BinTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树的链表表示 5(遍历)+2(叶子和高度)+1(创建)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.当前结点的左子树</span></span><br><span class=\"line\">    PtrToTNode Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.当前结点的右子树</span></span><br><span class=\"line\">    PtrToTNode Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> BT == <span class=\"literal\">NULL</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 二叉遍历，有先序遍历、中序遍历、后序遍历、堆栈遍历、层次遍历</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">CreatBinTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   BinTree BT;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请树TNode空间</span></span><br><span class=\"line\">   BT = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.初始化树的左、右孩子为NULL</span></span><br><span class=\"line\">   BT-&gt;Left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   BT-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> BT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中序遍历 左-根-右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.一路递归向左子树走</span></span><br><span class=\"line\">       InOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 4.再转身树的右子树递归</span></span><br><span class=\"line\">       InOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先序遍历 根-左-右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 3.一路递归向左子树走</span></span><br><span class=\"line\">       PreOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 4.再转身树的右子树递归</span></span><br><span class=\"line\">       PreOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后序遍历，左-右-根</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.一路递归向左子树走</span></span><br><span class=\"line\">       PostOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.再转身树的右子树递归</span></span><br><span class=\"line\">       PostOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">       <span class=\"comment\">// 4.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非递归遍历 - 堆栈实现中序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderTraversalStack</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   BinTree  T;</span><br><span class=\"line\">   <span class=\"comment\">// 1.创建堆栈</span></span><br><span class=\"line\">   Stack S = CreateStack();</span><br><span class=\"line\">   T = BT;</span><br><span class=\"line\">   <span class=\"comment\">// 2.树T不为空，或栈S不为空，就一直循环</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (T || !IsEmpty(S))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 3.遍历左子树，并将沿途结点压入栈</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> (T)&#123;</span><br><span class=\"line\">           Push(S, T);</span><br><span class=\"line\">           T = T-&gt;Left;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 4.将最深层的左树结点从堆栈中弹出T，并访问</span></span><br><span class=\"line\">       T = Pop(S);</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 5.转向访问该结点T的右子树</span></span><br><span class=\"line\">       T = T-&gt;Right;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非递归遍历 - 层序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   Queue Q;</span><br><span class=\"line\">   BinTree  T;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判空BT</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!BT)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.创建空队列</span></span><br><span class=\"line\">   Q = CreateQueue();</span><br><span class=\"line\">   <span class=\"comment\">// 3.将根结点加到队列中</span></span><br><span class=\"line\">   AddQ(Q, BT);</span><br><span class=\"line\">   <span class=\"comment\">// 4.遍历队列Q至空</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (!IsEmpty(Q))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 5.从队列中取出一个元素结点，访问打印</span></span><br><span class=\"line\">       T = Delete(Q);</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 6.如果结点左子树不为空，将结点的左子树添加到队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (T-&gt;Left) &#123;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Left);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 7.如果结点右子树不为空，将结点的右子树添加到队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (T-&gt;Right)&#123;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Right);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求所有叶子结点（基于先序遍历）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderPrintLeaves</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否有子孩子,无则是叶子结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!BT-&gt;Left &amp;&amp; !BT-&gt;Right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3.递归向左子树</span></span><br><span class=\"line\">        PreOrderPrintLeaves(BT-&gt;Left);</span><br><span class=\"line\">        <span class=\"comment\">// 4.递归向右子树</span></span><br><span class=\"line\">        PreOrderPrintLeaves(BT-&gt;Right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求二叉树的高度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> HL, HR, MaxH;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判空NULL</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.递归求左子树的高度HL</span></span><br><span class=\"line\">       HL = GetHeight(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.递归求右子树的高度HR</span></span><br><span class=\"line\">       HR = GetHeight(BT-&gt;Right);</span><br><span class=\"line\">       <span class=\"comment\">// 4.返回较大者MaxH，+1指包含当前层</span></span><br><span class=\"line\">       MaxH = HL &gt; HR ? HL : HR;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> MaxH + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 空树返回0</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据层序遍历生成二叉树</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">CreateBinTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BinTree BT, T;</span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建队列Q</span></span><br><span class=\"line\">   Queue Q = CreateQueue();</span><br><span class=\"line\">   <span class=\"comment\">// 2.读入根结点数据</span></span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Data != NoInfo) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 3.动态申请空结点BT，赋值给结点并初始化左右子树为NULL</span></span><br><span class=\"line\">       BT = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">       BT-&gt;Data = Data;</span><br><span class=\"line\">       BT-&gt;Left = BT-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 4.将根结点BT加入队列</span></span><br><span class=\"line\">       AddQ(Q, BT);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.如果队列不为空，遍历队列</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (!IsEmpty(Q))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 6.Q出列得到T</span></span><br><span class=\"line\">       T = DeleteQ(Q);</span><br><span class=\"line\">       <span class=\"comment\">// 7.读取左子树数据</span></span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Data != NoInfo)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 8.如果输入的数据不为空，则插入T的左子树，并加入队列Q</span></span><br><span class=\"line\">           T-&gt;Left = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">           T-&gt;Left-&gt;Data = Data;</span><br><span class=\"line\">           T-&gt;Left-&gt;Left = T-&gt;Left-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Left);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           T-&gt;Left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 9.读取右子树数据</span></span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Data != NoInfo)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 10.如果输入的数据不为空，则插入T的右子树，并加入队列Q</span></span><br><span class=\"line\">           T-&gt;Right = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">           T-&gt;Right-&gt;Data = Data;</span><br><span class=\"line\">           T-&gt;Right-&gt;Left = T-&gt;Right-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Right);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           T-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_大顶堆","url":"/2021/07/24/%E6%A0%91%E7%BB%93%E6%9E%84_%E5%A4%A7%E9%A1%B6%E5%A0%86/","content":"<h4 id=\"树结构-大顶堆结构及其操作\"><a href=\"#树结构-大顶堆结构及其操作\" class=\"headerlink\" title=\"树结构 - 大顶堆结构及其操作\"></a>树结构 - 大顶堆结构及其操作</h4><h5 id=\"结构-HeapStruct-MaxHeap\"><a href=\"#结构-HeapStruct-MaxHeap\" class=\"headerlink\" title=\"结构 HeapStruct - MaxHeap\"></a>结构 HeapStruct - MaxHeap</h5><ol>\n<li>存放结点数据的数组Elements，从1位置开始存，0位置放哨兵</li>\n<li>数组元素个数Size</li>\n<li>数组最大容量Capacity</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请堆空间</li>\n<li>动态申请堆的数组空间大小为MaxSize</li>\n<li>初始化大小及容量</li>\n<li>在堆的数组第0个元素存入哨兵，最大或最小值</li>\n</ol>\n<h5 id=\"堆是否为空\"><a href=\"#堆是否为空\" class=\"headerlink\" title=\"堆是否为空\"></a>堆是否为空</h5><ol>\n<li>判断堆的size是否为0</li>\n</ol>\n<h5 id=\"堆是否已满\"><a href=\"#堆是否已满\" class=\"headerlink\" title=\"堆是否已满\"></a>堆是否已满</h5><ol>\n<li>判断堆的size是否等于堆的容量</li>\n</ol>\n<h5 id=\"将元素item插入堆\"><a href=\"#将元素item插入堆\" class=\"headerlink\" title=\"将元素item插入堆\"></a>将元素item插入堆</h5><ol>\n<li>判断堆是已满</li>\n<li>找到堆数组的最后位置++H-&gt;Size</li>\n<li>遍历数组最末位元素结点至根结点，与插入值item比较，直到item小于父结点</li>\n<li>如果插入的元素item大于它的父结点，则需要换位，并找到新插入点的合适位置</li>\n<li>遍历结束找到新结点item有位置i</li>\n</ol>\n<h5 id=\"删除堆的根结点，最大元素\"><a href=\"#删除堆的根结点，最大元素\" class=\"headerlink\" title=\"删除堆的根结点，最大元素\"></a>删除堆的根结点，最大元素</h5><ol>\n<li>判断堆是否为空</li>\n<li>找到堆的最大元素即根结点</li>\n<li>将堆数组最末位元素Temp拎出增补空缺</li>\n<li>遍历整个堆p*2&lt;size,找到最末位结点的新位置</li>\n<li>比较左、右子树的大小，取较大者</li>\n<li>如果最末位元素Temp大于左、右子树，则不处理，否则左、右子树较大者覆盖父结点</li>\n<li>遍历结束，找到Temp位置parent，插入元素</li>\n</ol>\n<h5 id=\"下滤：将H-gt-Element-P-为根的子堆调整为最大堆\"><a href=\"#下滤：将H-gt-Element-P-为根的子堆调整为最大堆\" class=\"headerlink\" title=\"下滤：将H-&gt;Element[P]为根的子堆调整为最大堆\"></a>下滤：将H-&gt;Element[P]为根的子堆调整为最大堆</h5><ol>\n<li>找到位置P对应的值X</li>\n<li>遍历以P为根结点的整棵树</li>\n<li>取结点左、右子树较大者</li>\n<li>如果父结点X的值比子结点大，不处理，否则父子换位</li>\n<li>遍历结束，找到P对应的位置Parent，插入原来的根结点值</li>\n</ol>\n<h5 id=\"将完全二叉树调整为最大堆\"><a href=\"#将完全二叉树调整为最大堆\" class=\"headerlink\" title=\"将完全二叉树调整为最大堆\"></a>将完全二叉树调整为最大堆</h5><ol>\n<li>从最后一个有子孩子的结点(size/2)向前进行下滤</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXDATA 1000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">MaxHeap</span>;</span><span class=\"comment\">// 大顶堆</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.存放结点数据的数组，从1位置开始存，0位置放哨兵</span></span><br><span class=\"line\">    ElementType *Elements;</span><br><span class=\"line\">    <span class=\"comment\">// 2.数组元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Size;</span><br><span class=\"line\">    <span class=\"comment\">// 3.数组最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Capacity;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(MaxHeap H)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(MaxHeap H)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">MaxHeap <span class=\"title\">Create</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请堆空间</span></span><br><span class=\"line\">   MaxHeap H = (MaxHeap) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct HeapStruct));</span><br><span class=\"line\">   <span class=\"comment\">// 2.动态申请堆的数组空间大小为MaxSize</span></span><br><span class=\"line\">   H-&gt;Elements = (ElementType) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType) * MaxSize);</span><br><span class=\"line\">   <span class=\"comment\">// 3.初始化大小及容量</span></span><br><span class=\"line\">   H-&gt;Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">   H-&gt;Capacity = MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 4.在堆的数组第0个元素存入哨兵，最大或最小值</span></span><br><span class=\"line\">   H-&gt;Elements[<span class=\"number\">0</span>] = MAXDATA; <span class=\"comment\">//建立哨兵</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断堆的size是否为0</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H-&gt;Size == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断堆的size是否等于堆的容量</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H-&gt;Size == H-&gt;Capacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将元素item插入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(MaxHeap H, ElementType item)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断堆是已满</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsFull(H)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大堆已满&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到堆数组的最后位置++H-&gt;Size</span></span><br><span class=\"line\">   i = ++H-&gt;Size; <span class=\"comment\">// 新插入的元素加在堆的最后一个位置</span></span><br><span class=\"line\">   <span class=\"comment\">// H-&gt;Element[0]为最大元素，为哨兵结点，H-&gt;Elements[i / 2] &lt; item可控制循环结点</span></span><br><span class=\"line\">   <span class=\"comment\">// 3.遍历数组最末位元素结点至根结点，与插入值item比较，直到item小于父结点</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (; H-&gt;Elements[i / <span class=\"number\">2</span>] &lt; item; i /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 4.如果插入的元素item大于它的父结点，则需要换位，并找到新插入点的合适位置</span></span><br><span class=\"line\">       H-&gt;Elements[i] = H-&gt;Elements[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.遍历结束找到新结点item有位置i</span></span><br><span class=\"line\">   H-&gt;Elements[i] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 删除堆中的最大元素，即根结点</span></span><br><span class=\"line\"><span class=\"comment\">* 每层比较 根结点 左+右子结点，以及最后一个元素结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">DeleteMax</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">   ElementType MaxItem, Temp;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> Parent, Child;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断堆是否为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsEmpty(H)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大堆为空&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到堆的最大元素即根结点</span></span><br><span class=\"line\">   MaxItem = H-&gt;Elements[<span class=\"number\">1</span>];</span><br><span class=\"line\">   <span class=\"comment\">// 3.将堆数组最末位元素Temp拎出增补空缺</span></span><br><span class=\"line\">   Temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class=\"line\">   <span class=\"comment\">// 4.遍历整个堆p*2&lt;size,找到最末位结点的新位置</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Parent = <span class=\"number\">1</span>; Parent * <span class=\"number\">2</span> &lt; H-&gt;Size; Parent = Child) &#123;</span><br><span class=\"line\">       Child = Parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 5.比较左、右子树的大小，取较大者</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">           Child++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//6. 如果最末位元素Temp大于左、右子树，则不处理，否则左、右子树较大者覆盖父结点</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Temp &gt; H-&gt;Elements[Child])</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 7.遍历结束，找到Temp位置parent，插入元素</span></span><br><span class=\"line\">   H-&gt;Elements[Parent] = Temp;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> MaxItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 下滤:将H-&gt;Elemets[p]为根的子堆调整为最大堆</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">* @param P</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PercDown</span><span class=\"params\">(MaxHeap H, <span class=\"keyword\">int</span> P)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> Parent, Child;</span><br><span class=\"line\">   ElementType X;</span><br><span class=\"line\">   <span class=\"comment\">// 1.找到位置P对应的值X</span></span><br><span class=\"line\">   X = H-&gt;Elements[P];</span><br><span class=\"line\">   <span class=\"comment\">// 2.遍历以P为根结点的整棵树</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Parent = P; Parent * <span class=\"number\">2</span> &lt;= H-&gt;Size; Parent = Child) &#123;</span><br><span class=\"line\">       Child = Parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 3.取结点左、右子树较大者</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class=\"number\">1</span>]))</span><br><span class=\"line\">           Child++;</span><br><span class=\"line\">           <span class=\"comment\">// 4.如果父结点X的值比子结点大，不处理，否则父子换位</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (X &gt;= H-&gt;Elements[Child])</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.遍历结束，找到P对应的位置Parent，插入原来的根结点值</span></span><br><span class=\"line\">   H-&gt;Elements[Parent] = X;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 建立最大堆，并不断地将小的元素下滤</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">// 1.从最后一个有子孩子的结点(size/2)向前进行下滤</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = H-&gt;Size / <span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">       PercDown(H, i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//验证构建、删除、插入大顶堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> maxNum, i;</span><br><span class=\"line\">   ElementType value;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input the heap numbers:\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;maxNum);</span><br><span class=\"line\">   MaxHeap Heap = Create(maxNum);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input %d numbers:\\n&quot;</span>, maxNum);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; maxNum; i++) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;value);</span><br><span class=\"line\">       Insert(Heap, value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The root value is: %d\\n&quot;</span>, Heap-&gt;Elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"comment\">//    value = DeleteMax(Heap);</span></span><br><span class=\"line\"><span class=\"comment\">// 先注释插入时与根结点的比较,先只构造完全二叉树的结构，最通过下滤构造大顶堆</span></span><br><span class=\"line\">   BuildHeap(Heap);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;after delete, the value is: %d\\n&quot;</span>, Heap-&gt;Elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_平衡二叉树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h4 id=\"树结构-平衡二叉树结构及其操作\"><a href=\"#树结构-平衡二叉树结构及其操作\" class=\"headerlink\" title=\"树结构 - 平衡二叉树结构及其操作\"></a>树结构 - 平衡二叉树结构及其操作</h4><h5 id=\"结构-AVLNode-Position-AVLTree\"><a href=\"#结构-AVLNode-Position-AVLTree\" class=\"headerlink\" title=\"结构 AVLNode - Position - AVLTree\"></a>结构 AVLNode - Position - AVLTree</h5><ol>\n<li>结点的数据Data</li>\n<li>结点的左子树</li>\n<li>结点的右子树</li>\n<li>以当前结点为根的树高</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"将X插入平衡树-递归实现\"><a href=\"#将X插入平衡树-递归实现\" class=\"headerlink\" title=\"将X插入平衡树(递归实现)\"></a>将X插入平衡树(递归实现)</h5><ol>\n<li>如果为空则说明找到需要插入的位置</li>\n<li>动态申请新结点AVLNode,将待插值X赋值给新结点T</li>\n<li>初始化左右子树为NULL,树高为1</li>\n<li>如果X比结点元素值小，则向左搜索插入点</li>\n<li>如果平衡因子(左-右)大于等于2，需要左旋</li>\n<li>如果插入点在左子树的左边，则单左旋，在左子树的右边则进行左-右旋</li>\n<li>如果X比结点元素值大，则向右搜索插入点</li>\n<li>如果平衡因子(左-右)大于等于2，需要右旋</li>\n<li>如果插入点在右子树的右边，则单右旋，在右子树的左边则进行右-左旋</li>\n</ol>\n<h5 id=\"左单旋\"><a href=\"#左单旋\" class=\"headerlink\" title=\"左单旋\"></a>左单旋</h5><ol>\n<li>结点A必须有一个左子结点，将A与B做左单旋，更新A与B的高度</li>\n<li>将B的右子树挂在A的左子树上，B不在为A左子树， 如果B有右子树的话</li>\n<li>A作为B的右子树，完成左旋</li>\n<li>重新计算树A,B高度</li>\n<li>B为新的根结点</li>\n</ol>\n<h5 id=\"右单旋\"><a href=\"#右单旋\" class=\"headerlink\" title=\"右单旋\"></a>右单旋</h5><ol>\n<li>A必须有右子树，将A与B右单旋</li>\n<li>将右子树B的左边挂在根结点A的右为，B不再为A的右结点</li>\n<li>将A作为B的左子树</li>\n<li>重新的计算树高度</li>\n<li>B为新的根结点</li>\n</ol>\n<h5 id=\"左-右双旋\"><a href=\"#左-右双旋\" class=\"headerlink\" title=\"左 - 右双旋\"></a>左 - 右双旋</h5><ol>\n<li>先以左子树为根结点右旋转</li>\n<li>后以发现者为根结点左旋转</li>\n</ol>\n<h5 id=\"右-左双旋\"><a href=\"#右-左双旋\" class=\"headerlink\" title=\"右 - 左双旋\"></a>右 - 左双旋</h5><ol>\n<li>先以右子树为根结点进行左旋转</li>\n<li>再以发现者为根结点右旋转</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVLNode</span> *<span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Position AVLTree;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVLNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.结点的左子树</span></span><br><span class=\"line\">    AVLTree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.结点的右子树</span></span><br><span class=\"line\">    AVLTree Right;</span><br><span class=\"line\">    <span class=\"comment\">// 4.以当前结点为根的树高</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(AVLTree AT)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleLeftRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleRightRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleLeftRightRation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleRightLeftRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将X插入到树A中,递归实现</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @param X</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">Insert</span><span class=\"params\">(AVLTree T, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.如果为空则说明找到需要插入的位置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!T) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.动态申请新结点AVLNode,将待插值X赋值给新结点T</span></span><br><span class=\"line\">       T = (AVLTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AVLNode));</span><br><span class=\"line\">       T-&gt;Data = X;</span><br><span class=\"line\">       <span class=\"comment\">// 3.初始化左右子树为NULL,树高为1</span></span><br><span class=\"line\">       T-&gt;Height = <span class=\"number\">1</span>;</span><br><span class=\"line\">       T-&gt;Left = T-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &lt; T-&gt;Data) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 4.如果X比结点元素值小，则向左搜索插入点</span></span><br><span class=\"line\">       T-&gt;Left = Insert(T-&gt;Left, X);</span><br><span class=\"line\">       <span class=\"comment\">// 5.如果平衡因子(左-右)大于等于2，需要左旋</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 6.如果插入点在左子树的左边，则单左旋，在左子树的右边则进行左-右旋</span></span><br><span class=\"line\">           <span class=\"comment\">// T为发现者</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (X &lt; T-&gt;Left-&gt;Data) &#123;</span><br><span class=\"line\">               T = SingleLeftRotation(T);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               T = DoubleLeftRightRation(T);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &gt; T-&gt;Data) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 7.如果X比结点元素值大，则向右搜索插入点</span></span><br><span class=\"line\">       T-&gt;Right = Insert(T-&gt;Right, X);</span><br><span class=\"line\">       <span class=\"comment\">// 8.如果平衡因子(左-右)大于等于2，需要右旋</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 9.如果插入点在右子树的右边，则单右旋，在右子树的左边则进行右-左旋</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (X &gt; T-&gt;Right-&gt;Data) &#123;</span><br><span class=\"line\">               T = SingleRightRotation(T);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               T = DoubleRightLeftRotation(T);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;<span class=\"comment\">/* else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">       X = T-&gt;Data;// 无需要插入</span></span><br><span class=\"line\"><span class=\"comment\">   &#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 左-右双旋</span></span><br><span class=\"line\"><span class=\"comment\">* 破坏结点在发现者的左子树的右子树上，</span></span><br><span class=\"line\"><span class=\"comment\">* 先以左子树为根结点进行右旋转再发现者为根结点进行左旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleLeftRightRation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.先以左子树为根结点右旋转,后以发现者为根结点左旋转</span></span><br><span class=\"line\">   A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> SingleLeftRotation(A);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 右-左双旋</span></span><br><span class=\"line\"><span class=\"comment\">* 破坏者在发现者的右子树的左子树上，</span></span><br><span class=\"line\"><span class=\"comment\">* 先以右子树为根结点进行左旋转，再以发现者为根结点进行右旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleRightLeftRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.先以右子树为根结点进行左旋转，再以发现者为根结点右旋转</span></span><br><span class=\"line\">   A-&gt;Right = SingleLeftRotation(A-&gt;Right);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> SingleRightRotation(A);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 左单旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleLeftRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.结点A必须有一个左子结点，将A与B做左单旋，更新A与B的高度</span></span><br><span class=\"line\">   AVLTree B = A-&gt;Left;</span><br><span class=\"line\">   <span class=\"comment\">// 2.如果B有右子树的话,将B的右子树挂在A的左子树上，B不在为A左子树</span></span><br><span class=\"line\">   A-&gt;Left = B-&gt;Right;</span><br><span class=\"line\">   <span class=\"comment\">// 3.A作为B的右子树，完成左旋</span></span><br><span class=\"line\">   B-&gt;Right = A;</span><br><span class=\"line\">   <span class=\"comment\">// 4.重新计算树A,B高度</span></span><br><span class=\"line\">   A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   B-&gt;Height = Max(GetHeight(B-&gt;Left), GetHeight(B-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 5.B为新的根结点</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 右单旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleRightRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.A必须有右子树，将A与B右单旋</span></span><br><span class=\"line\">   AVLTree B = A-&gt;Right;</span><br><span class=\"line\">   <span class=\"comment\">// 2.将右子树B的左边挂在根结点A的右为，B不再为A的右结点</span></span><br><span class=\"line\">   A-&gt;Right = B-&gt;Left;</span><br><span class=\"line\">   <span class=\"comment\">// 3.将A作为B的左子树</span></span><br><span class=\"line\">   B-&gt;Left = A;</span><br><span class=\"line\">   <span class=\"comment\">// 4.重新的计算树高度</span></span><br><span class=\"line\">   A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   B-&gt;Height = Max(GetHeight(B-&gt;Left), GetHeight(B-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 获取平衡二叉树的高度,递归</span></span><br><span class=\"line\"><span class=\"comment\">* @param AT</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(AVLTree AT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> HL, HR, Max;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (AT) &#123;</span><br><span class=\"line\">       HL = GetHeight(AT-&gt;Left);</span><br><span class=\"line\">       HR = GetHeight(AT-&gt;Right);</span><br><span class=\"line\">       Max = HL &gt; HR ? HL : HR;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Max + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"数据结构_线性表","url":"/2021/07/19/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E8%A1%A8/","content":"<h4 id=\"线性结构-线性表的顺序存储表示及其操作\"><a href=\"#线性结构-线性表的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 线性表的顺序存储表示及其操作\"></a>线性结构 - 线性表的顺序存储表示及其操作</h4><h5 id=\"结构-LNode-PtrToLNode-List\"><a href=\"#结构-LNode-PtrToLNode-List\" class=\"headerlink\" title=\"结构 LNode - PtrToLNode - List\"></a>结构 LNode - PtrToLNode - List</h5><ol>\n<li>实际存储元素的数组Data[MAXSIZE]</li>\n<li>游标，指向最后一个元素Last</li>\n</ol>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><a id=\"more\"></a>\n\n<ol>\n<li>动态申请大小为一个List的内存,也可以指定其数组的大小</li>\n<li>初始化游标Last为-1</li>\n</ol>\n<h5 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h5><ol>\n<li>遍历数组，直到数组最后一个元素或找到元素X</li>\n<li>如果i大于最后一个元素，表示未找到，否则已找到</li>\n</ol>\n<h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><ol>\n<li>先判断表是否已满</li>\n<li>判断插入的位序是否合法</li>\n<li>循环遍历从末位向后复制，空出第i+1的位置</li>\n<li>将新元素X赋值给i+i，完成插入</li>\n<li>游标Last加1</li>\n</ol>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><ol>\n<li>先判断是删除的位置是否合法</li>\n<li>循环遍历从第i位之后的元素向前移一位，将第i个元素覆盖</li>\n<li>游标Last减1</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position; <span class=\"comment\">// 位置</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType; <span class=\"comment\">// 元素</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span><span class=\"comment\">// 结构体起始位置</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.实际存储元素的数组</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"comment\">// 2.游标，指向最后一个元素</span></span><br><span class=\"line\">    Position Last; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List L;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 动态申请大小为一个List的内存,也可以指定其数组的大小</span></span><br><span class=\"line\">    L = (List) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct LNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化游标Last为-1</span></span><br><span class=\"line\">    L-&gt;Last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">Find</span><span class=\"params\">(List L, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历数组，直到数组最后一个元素或找到元素X</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果i大于最后一个元素，表示未找到，否则已找到</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; L-&gt;Last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(List L, ElementType X, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先判断表是否已满</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;Last == MAXSIZE - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;表满&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.判断插入的位序是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L-&gt;Last + <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位序不合法&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Position j;</span><br><span class=\"line\">    <span class=\"comment\">// 3.循环遍历从末位向后复制，空出第i+1的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = L-&gt;Last; j &gt;= i - <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">        L-&gt;Data[j + <span class=\"number\">1</span>] = L-&gt;Data[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.将新元素X赋值给i+i，完成插入</span></span><br><span class=\"line\">    L-&gt;Data[i - <span class=\"number\">1</span>] = X;</span><br><span class=\"line\">    <span class=\"comment\">// 5. 游标Last加1</span></span><br><span class=\"line\">    L-&gt;Last++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(List L, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是删除的位置是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L-&gt;Last) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位序%d不正确&quot;</span>, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Position j;</span><br><span class=\"line\">    <span class=\"comment\">// 2.循环遍历从第i位之后的元素向前移一位，将第i个元素覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; j &lt; L-&gt;Last; j++) &#123;</span><br><span class=\"line\">        L-&gt;Data[j] = L-&gt;Data[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 游标Last减1</span></span><br><span class=\"line\">    L-&gt;Last--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-线性表的链式存储表示及其操作\"><a href=\"#线性结构-线性表的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 线性表的链式存储表示及其操作\"></a>线性结构 - 线性表的链式存储表示及其操作</h4><h5 id=\"结构-LNode-PtrToLNode-List-1\"><a href=\"#结构-LNode-PtrToLNode-List-1\" class=\"headerlink\" title=\"结构  LNode - PtrToLNode - List\"></a>结构  LNode - PtrToLNode - List</h5><ol>\n<li>当前结点的数据Data</li>\n<li>下一个结点Next</li>\n</ol>\n<h5 id=\"求表长\"><a href=\"#求表长\" class=\"headerlink\" title=\"求表长\"></a>求表长</h5><ol>\n<li>循环遍历，并累加变量len</li>\n</ol>\n<h5 id=\"查找（按位序）\"><a href=\"#查找（按位序）\" class=\"headerlink\" title=\"查找（按位序）\"></a>查找（按位序）</h5><ol>\n<li>位序从第一个元素开始</li>\n<li>p指向第一个结点</li>\n<li>如果指针到指定的index还没有找到，或是扫描到最后的元素NULL,则退出</li>\n<li>指针指向index位置，同时不为NULL</li>\n</ol>\n<h5 id=\"查找（按元素）\"><a href=\"#查找（按元素）\" class=\"headerlink\" title=\"查找（按元素）\"></a>查找（按元素）</h5><ol>\n<li>p指向第一个结点</li>\n<li>当指针遍历到最后为NULL或是找到元素X，则退出</li>\n<li>如果p不为NULL，表示找到元素，返回p，否则返回NULL</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType; <span class=\"comment\">// 元素</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 当前结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 下一个结点Next</span></span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求表长</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">(PtrToLNode L)</span> </span>&#123;</span><br><span class=\"line\">    Position P;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    P = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (P) &#123;</span><br><span class=\"line\">        P = P-&gt;Next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找,按index</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">FindElementByIndex</span><span class=\"params\">(List L, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    Position p;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 位序从第一个元素开始</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. p指向第一个结点</span></span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果指针到指定的index还没有找到，或是扫描到最后的元素NULL,则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt &lt; index &amp;&amp; p) &#123;</span><br><span class=\"line\">        p = p-&gt;Next;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 指针指向index位置，同时不为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt == index &amp;&amp; p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;Data;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找，按元素</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindElement</span><span class=\"params\">(List L, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position p;</span><br><span class=\"line\">    <span class=\"comment\">// 1. p指向第一个结点</span></span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 当指针遍历到最后为NULL或是找到元素X，则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; p-&gt;Next != X) &#123;</span><br><span class=\"line\">        p = p-&gt;Next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果不为NULL，表示找到元素，返回p，否则返回NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","线性表"]},{"title":"数据结构_堆栈","url":"/2021/07/19/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E5%A0%86%E6%A0%88/","content":"<h4 id=\"线性结构-堆栈的顺序存储表示及其操作\"><a href=\"#线性结构-堆栈的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 堆栈的顺序存储表示及其操作\"></a>线性结构 - 堆栈的顺序存储表示及其操作</h4><h5 id=\"结构-SNode-PtrToSNode-Stack\"><a href=\"#结构-SNode-PtrToSNode-Stack\" class=\"headerlink\" title=\"结构 SNode - PtrToSNode - Stack\"></a>结构 SNode - PtrToSNode - Stack</h5><ol>\n<li>堆栈中的数组，用于存放数据Data</li>\n<li>栈顶指针Top,可用于判断是否空或满</li>\n<li>栈的最大容量MaxSize</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请栈空间Stack</li>\n<li>初始化Top指针为-1，及最大容量</li>\n<li>动态申请Stack中数组的空间</li>\n</ol>\n<h5 id=\"是否已满\"><a href=\"#是否已满\" class=\"headerlink\" title=\"是否已满\"></a>是否已满</h5><ol>\n<li>栈顶指针Top是否与数组最大容量-1相等</li>\n</ol>\n<h5 id=\"是否为空\"><a href=\"#是否为空\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>判断Top指针是否为-1</li>\n</ol>\n<h5 id=\"压栈\"><a href=\"#压栈\" class=\"headerlink\" title=\"压栈\"></a>压栈</h5><ol>\n<li>先判断是已经满了</li>\n<li>将元素存放到Stack的数组的最后一个空位上</li>\n<li>Stack的Top指针加1</li>\n</ol>\n<h5 id=\"弹栈\"><a href=\"#弹栈\" class=\"headerlink\" title=\"弹栈\"></a>弹栈</h5><ol>\n<li>判断Stack是否为空</li>\n<li>将栈顶元素返回，即Stack中数组的最末位,Top</li>\n<li>栈顶指针Top下移一位，原来的栈顶元素就无法被访问了，可不删除或覆盖</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 堆栈中的数组，用于存放数据</span></span><br><span class=\"line\">    ElementType *Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 栈顶指针,可用于判断是否空或满</span></span><br><span class=\"line\">    Position Top;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 栈的最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToSNode Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Stack <span class=\"title\">CreateStack</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span>&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请栈空间Stack</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化Top指针为-1，及最大容量</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 动态申请Stack中数组的空间</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Data = (ElementType *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType) * MaxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶指针Top是否与数组最大容量-1相等</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"built_in\">stack</span>-&gt;Top == <span class=\"built_in\">stack</span>-&gt;MaxSize <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断Top指针是否为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Top == <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先判断是已经满了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span>-&gt;Top == <span class=\"built_in\">stack</span>-&gt;MaxSize <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;stack is full&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 将元素存放到Stack的数组的最后一个空位上</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. Stack的Top指针加1</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Data[++(<span class=\"built_in\">stack</span>-&gt;Top)] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹栈</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Pop</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1、判断Stack是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>-&gt;Top == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 将栈顶元素返回，即Stack中数组的最末位,Top</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 栈顶指针Top下移一位，原来的栈顶元素就无法被访问了，可不删除或覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Data[(<span class=\"built_in\">stack</span>-&gt;Top)--];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-堆栈的链式存储表示及其操作\"><a href=\"#线性结构-堆栈的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 堆栈的链式存储表示及其操作\"></a>线性结构 - 堆栈的链式存储表示及其操作</h4><h5 id=\"结构-SNode-PtrToSNode-Stack-1\"><a href=\"#结构-SNode-PtrToSNode-Stack-1\" class=\"headerlink\" title=\"结构 SNode - PtrToSNode - Stack\"></a>结构 SNode - PtrToSNode - Stack</h5><ol>\n<li>结点的数据Data</li>\n<li>下一个结点Next</li>\n</ol>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请Stack空间，并初始化下一个结点Next为NULL</li>\n</ol>\n<h5 id=\"判断是否为空\"><a href=\"#判断是否为空\" class=\"headerlink\" title=\"判断是否为空\"></a>判断是否为空</h5><ol>\n<li>判断头结点的下一个结点是否为NULL</li>\n</ol>\n<h5 id=\"压栈-1\"><a href=\"#压栈-1\" class=\"headerlink\" title=\"压栈\"></a>压栈</h5><ol>\n<li>动态申请新结点的空间，创建新结点node</li>\n<li>将新值item赋值给新结点node</li>\n<li>新结点的下一个结点指向栈的头结点下一个结点（第一个结点）</li>\n<li>头结点的下一个结点(第一个结点)为新结点node，链表头插入头删除</li>\n</ol>\n<h5 id=\"弹栈-1\"><a href=\"#弹栈-1\" class=\"headerlink\" title=\"弹栈\"></a>弹栈</h5><ol>\n<li>判断栈是否为空</li>\n<li>用临时结点firstItem暂存第一个结点，value暂存第一个结点的值</li>\n<li>头结点的下一个结点指向第一个结点的下一个结点(第二个结点)，删除原来的第一个结点</li>\n<li>释放原来的第一个结点firstItem</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToSNode Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.下一个结点Next</span></span><br><span class=\"line\">    PtrToSNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Stack <span class=\"title\">CreateStack</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请Stack空间，并初始化下一个结点Next为NULL</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断栈是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmepty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断头结点的下一个结点是否为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Next == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToSNode node;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请新结点的空间，创建新结点node</span></span><br><span class=\"line\">    node = (PtrToSNode)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2.将新值item赋值给新结点node</span></span><br><span class=\"line\">    node-&gt;Data = item;</span><br><span class=\"line\">    <span class=\"comment\">// 3.新结点的下一个结点指向栈的头结点下一个结点（第一个结点）</span></span><br><span class=\"line\">    node-&gt;Next = <span class=\"built_in\">stack</span>-&gt;Next;</span><br><span class=\"line\">    <span class=\"comment\">// 4.头结点的下一个结点(第一个结点)为新结点node，链表头插入头删除</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹栈</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Pop</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isEmepty(<span class=\"built_in\">stack</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;stack is empty&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToSNode firstItem;</span><br><span class=\"line\">    ElementType value;</span><br><span class=\"line\">    <span class=\"comment\">// 2.用临时结点firstItem暂存第一个结点，value暂存第一个结点的值</span></span><br><span class=\"line\">    firstItem = <span class=\"built_in\">stack</span>-&gt;Next;</span><br><span class=\"line\">    value = firstItem-&gt;Data;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 头结点的下一个结点指向第一个结点的下一个结点(第二个结点)，删除原来的第一个结点</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = firstItem-&gt;Next;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 释放原来的第一个结点firstItem</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(firstItem);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","堆栈"]},{"title":"线性结构_队列","url":"/2021/07/20/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97/","content":"<h4 id=\"线性结构-队列的顺序存储表示及其操作\"><a href=\"#线性结构-队列的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 队列的顺序存储表示及其操作\"></a>线性结构 - 队列的顺序存储表示及其操作</h4><h5 id=\"结构-QNode-PtrToQNode-Queue\"><a href=\"#结构-QNode-PtrToQNode-Queue\" class=\"headerlink\" title=\"结构 QNode - PtrToQNode - Queue\"></a>结构 QNode - PtrToQNode - Queue</h5><ol>\n<li>数组Data存放元素，循环存放实现循环队列</li>\n<li>设置队头front与rear队尾两个指针</li>\n<li>队列的最大容量</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请队列Queue的空间</li>\n<li>动态申请队列中数组Data的空间,</li>\n<li>最大长度为MaxSize</li>\n<li>初始化队头front与队尾rear指针为0</li>\n</ol>\n<h5 id=\"是否为空\"><a href=\"#是否为空\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>队头front与队尾rear相等，则为空队列</li>\n</ol>\n<h5 id=\"是否已满\"><a href=\"#是否已满\" class=\"headerlink\" title=\"是否已满\"></a>是否已满</h5><ol>\n<li>队尾rear+1模以容量等于队头front，则队列已满</li>\n</ol>\n<h5 id=\"入列-队尾rear\"><a href=\"#入列-队尾rear\" class=\"headerlink\" title=\"入列 - 队尾rear\"></a>入列 - 队尾rear</h5><ol>\n<li>判断队列是否已满</li>\n<li>找到队列尾rear指针，在原指针加1后模以容量，以防在最队尾，重回队头</li>\n<li>在队列的数组Data的第rear个位置插入元素item</li>\n</ol>\n<h5 id=\"出列-队头front\"><a href=\"#出列-队头front\" class=\"headerlink\" title=\"出列 - 队头front\"></a>出列 - 队头front</h5><ol>\n<li>判断队列是否为空</li>\n<li>找到队头指针front,在原有指针上加1模以容量，如果在最末位，则重返数组第1位</li>\n<li>返回队头front指针的元素</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">PtrToQNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.数组Data存放元素，循环存放实现循环队列</span></span><br><span class=\"line\">   ElementType *Data;</span><br><span class=\"line\">   <span class=\"comment\">// 2.设置队头front与rear队尾两个指针</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> front, rear;</span><br><span class=\"line\">   <span class=\"comment\">// 3.队列的最大容量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToQNode Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span>&#123;</span><br><span class=\"line\">   Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请队列Queue的空间</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span> = (Queue)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.动态申请队列中数组Data的空间,</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data = (ElementType *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType)*MaxSize);</span><br><span class=\"line\">   <span class=\"comment\">// 3.最大长度为MaxSize</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 4.初始化队头front与队尾rear指针为0</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 队头front与队尾rear相等，则为空队列</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;rear == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.队尾rear+1模以容量等于队头front，则队列已满</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入列 - 队尾rear</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">add</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 判断队列是否已满</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isFull(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is full!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到队列尾rear指针，在原指针加1后模以容量，以防在最队尾，重回队头</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 3.在队列的数组Data的第rear个位置插入元素item</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;rear] = item;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出列 - 队头front</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Delete</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断队列是否为空</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到队头指针front,在原有指针上加1模以容量，如果在最末位，则重返数组第1位</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = (<span class=\"built_in\">queue</span>-&gt;front +<span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 3.返回队头front指针的元素</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-队列的链式存储表示及其操作\"><a href=\"#线性结构-队列的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 队列的链式存储表示及其操作\"></a>线性结构 - 队列的链式存储表示及其操作</h4><h5 id=\"结构-邻结点Node-PtrToNode-Position-头结点QNode-Queue\"><a href=\"#结构-邻结点Node-PtrToNode-Position-头结点QNode-Queue\" class=\"headerlink\" title=\"结构 邻结点Node - PtrToNode - Position 头结点QNode - Queue\"></a>结构 邻结点Node - PtrToNode - Position 头结点QNode - Queue</h5><h6 id=\"链表邻结点Node\"><a href=\"#链表邻结点Node\" class=\"headerlink\" title=\"链表邻结点Node\"></a>链表邻结点Node</h6><ol>\n<li>链表邻结点</li>\n<li>下一个结点Next</li>\n</ol>\n<h6 id=\"队列链表头结点\"><a href=\"#队列链表头结点\" class=\"headerlink\" title=\"队列链表头结点\"></a>队列链表头结点</h6><ol>\n<li>链表队列的头Front、尾结Rear点作为指针</li>\n<li>队列容量、长度</li>\n</ol>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请队列Queue空间</li>\n<li>初始化队列队头Front、队尾Rear指针为NULL</li>\n</ol>\n<h5 id=\"是否为空-1\"><a href=\"#是否为空-1\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>判断队头指针Front是否为NULL</li>\n</ol>\n<h5 id=\"入列-队尾\"><a href=\"#入列-队尾\" class=\"headerlink\" title=\"入列 - 队尾\"></a>入列 - 队尾</h5><ol>\n<li>动态申请邻结点Node空间</li>\n<li>将新插入的值item赋值给新结点node,并初始化Next为NULL</li>\n<li>如果队列为空，则Front和Rear都指向该结点,否则Rear指向该结点</li>\n</ol>\n<h5 id=\"出列-队头\"><a href=\"#出列-队头\" class=\"headerlink\" title=\"出列 - 队头\"></a>出列 - 队头</h5><ol>\n<li>判断队列是否为空</li>\n<li>根据队头指针找到头结点FrontCell及其数据</li>\n<li>如果队列中只有一个元素，队头Front、队尾Rear指针置为NULL，</li>\n<li>否则将头结点Front指向头结点的下一个结点(第二个结点)</li>\n<li>释放原来的头结点FrontCell</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表邻结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点数据Data</span></span><br><span class=\"line\">   ElementType Data;</span><br><span class=\"line\">   <span class=\"comment\">// 2.下一个结点Next</span></span><br><span class=\"line\">   PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列链表头结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.链表队列的头Front、尾结Rear点作为指针</span></span><br><span class=\"line\">   Position Front, Rear;</span><br><span class=\"line\">   <span class=\"comment\">// 2.队列容量、长度</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">Queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请队列Queue空间</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span> = (Queue) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.初始化队列队头Front、队尾Rear指针为NULL</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Front = <span class=\"built_in\">queue</span>-&gt;Rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断队头指针Front是否为NULL</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;Front == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入列 - 队尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, ElementType item)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   PtrToNode node;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请邻结点Node空间</span></span><br><span class=\"line\">   node = (PtrToNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Node));</span><br><span class=\"line\">   <span class=\"comment\">// 2.将新插入的值item赋值给新结点node,并初始化Next为NULL</span></span><br><span class=\"line\">   node-&gt;Data = item;</span><br><span class=\"line\">   node-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 3.如果队列为空，则Front和Rear都指向该结点,否则Rear指向该结点</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Front = node;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Rear = node;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Rear = node;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出列 - 队头</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Delete</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">   Position FrontCell;</span><br><span class=\"line\">   ElementType FrontElem;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断队列是否为空</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.根据队头指针找到头结点FrontCell及其数据</span></span><br><span class=\"line\">       FrontCell = <span class=\"built_in\">queue</span>-&gt;Front;</span><br><span class=\"line\">       FrontElem = FrontCell-&gt;Data;</span><br><span class=\"line\">       <span class=\"comment\">// 3.如果队列中只有一个元素，队头Front、队尾Rear指针置为NULL，</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;Front == <span class=\"built_in\">queue</span>-&gt;Rear) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">queue</span>-&gt;Front = <span class=\"built_in\">queue</span>-&gt;Rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 4.否则将头结点Front指向头结点的下一个结点(第二个结点)</span></span><br><span class=\"line\">           <span class=\"built_in\">queue</span>-&gt;Front = FrontCell-&gt;Next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 5.释放原来的头结点FrontCell</span></span><br><span class=\"line\">       <span class=\"built_in\">free</span>(FrontCell);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> FrontElem;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","队列"]}]