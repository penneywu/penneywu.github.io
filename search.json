[{"title":"01-复杂度3 二分查找","url":"/2021/07/24/01-%E5%A4%8D%E6%9D%82%E5%BA%A63-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"<p>本题要求实现二分查找算法。</p>\n<h4 id=\"函数接口定义：\"><a href=\"#函数接口定义：\" class=\"headerlink\" title=\"函数接口定义：\"></a>函数接口定义：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Position <span class=\"title\">BinarySearch</span><span class=\"params\">( List L, ElementType X )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中<code>List</code>结构定义如下：</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last; <span class=\"comment\">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p>\n<h4 id=\"裁判测试程序样例：\"><a href=\"#裁判测试程序样例：\" class=\"headerlink\" title=\"裁判测试程序样例：\"></a>裁判测试程序样例：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NotFound 0</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last; <span class=\"comment\">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">ReadInput</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* 裁判实现，细节不表。元素从下标1开始存储 */</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">BinarySearch</span><span class=\"params\">( List L, ElementType X )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    List L;</span><br><span class=\"line\">    ElementType X;</span><br><span class=\"line\">    Position P;</span><br><span class=\"line\"></span><br><span class=\"line\">    L = ReadInput();</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;X);</span><br><span class=\"line\">    P = BinarySearch( L, X );</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, P);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输入样例1：\"><a href=\"#输入样例1：\" class=\"headerlink\" title=\"输入样例1：\"></a>输入样例1：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">31</span> <span class=\"number\">55</span> <span class=\"number\">89</span> <span class=\"number\">101</span></span><br><span class=\"line\"><span class=\"number\">31</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输出样例1：\"><a href=\"#输出样例1：\" class=\"headerlink\" title=\"输出样例1：\"></a>输出样例1：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输入样例2：\"><a href=\"#输入样例2：\" class=\"headerlink\" title=\"输入样例2：\"></a>输入样例2：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">26</span> <span class=\"number\">78</span> <span class=\"number\">233</span></span><br><span class=\"line\"><span class=\"number\">31</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输出样例2：\"><a href=\"#输出样例2：\" class=\"headerlink\" title=\"输出样例2：\"></a>输出样例2：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NotFound 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">ReadInput</span><span class=\"params\">()</span></span>;<span class=\"comment\">//其它实现</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">BinarySearch</span><span class=\"params\">(List L, ElementType X)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List L;</span><br><span class=\"line\">    ElementType X;</span><br><span class=\"line\">    Position P;</span><br><span class=\"line\">    L = ReadInput();</span><br><span class=\"line\"></span><br><span class=\"line\">    ElementType arr[] = &#123;<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">78</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;X);</span><br><span class=\"line\">    P = BinarySearch(L, X);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;position:%d&quot;</span>, P);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 非递归分治法</span></span><br><span class=\"line\"><span class=\"comment\"> * 也可递归分治法</span></span><br><span class=\"line\"><span class=\"comment\"> * @param L</span></span><br><span class=\"line\"><span class=\"comment\"> * @param X</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">BinarySearch</span><span class=\"params\">(List L, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position position = NotFound;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = L-&gt;Last, mid;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历链表</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果元素X等于数组中间值，说明找到，返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (X == L-&gt;Data[mid]) &#123;</span><br><span class=\"line\">            position = mid;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 3.如果X比中间值大，left取mid+1向右查找</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &gt; L-&gt;Data[mid]) &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.如果X比中间值小，right取mid-1向左查找</span></span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结:\"></a>小结:</h4><ol>\n<li>遍历链表</li>\n<li>如果元素X等于数组中间值，说明找到，返回</li>\n<li>如果X比中间值大，left取mid+1向右查找</li>\n<li>如果X比中间值小，right取mid-1向左查找</li>\n</ol>\n","categories":["PTA"],"tags":["复杂度"]},{"title":"01-复杂度2 Maximum Subsequence Sum","url":"/2021/07/24/01-%E5%A4%8D%E6%9D%82%E5%BA%A62-Maximum-Subsequence-Sum/","content":"<p>​    Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>\n<a id=\"more\"></a>\n\n<p>​    Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<h5 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">-10</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">-5</span> <span class=\"number\">-23</span> <span class=\"number\">3</span> <span class=\"number\">7</span> <span class=\"number\">-21</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">1</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h5><p>求最大子列各，及子列的开始、结束位置</p>\n<h5 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSub</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> *index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_p5</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number, i, total, sum, index, arr[MAXSIZE];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; number; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    total = maxSub(arr, number, &amp;index);</span><br><span class=\"line\">    <span class=\"comment\">// 如果全为负数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        index = number <span class=\"number\">-1</span>;</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, total);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, arr[i], arr[index]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, total);</span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 从最大子列和最末位index向前遍历，至sum等于total，得到开始索引i</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = index; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        sum += arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == total) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, arr[i], arr[index]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线处理，即时处理算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSub</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N, <span class=\"keyword\">int</span> *index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ThisSum = <span class=\"number\">0</span>, MaxSum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        ThisSum += A[i]; <span class=\"comment\">// 向右累加</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">            MaxSum = ThisSum; <span class=\"comment\">// 发现更大和则更新当前结果</span></span><br><span class=\"line\">            *index = i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前子列和为负</span></span><br><span class=\"line\">            ThisSum = <span class=\"number\">0</span>; <span class=\"comment\">// 则不可能使后面的部分和增大，抛弃之</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>根据在线算法求得最大子列和，并用index标记子列的最末位置index</li>\n<li>根据index向前遍历数组，并累加子列和，至与最大和相等，记录索引i</li>\n<li>输入最大子列和，子列开始位置i，子列结束位置index</li>\n</ol>\n","categories":["PTA"],"tags":["复杂度"]},{"title":"01-复杂度1 最大子列和问题","url":"/2021/07/24/01-%E5%A4%8D%E6%9D%82%E5%BA%A61-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/","content":"<p>​    给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }，“连续子列”被定义为{ <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>\n<p>​    本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>数据1：与样例等价，测试基本正确性；</li>\n<li>数据2：102个随机整数；</li>\n<li>数据3：103个随机整数；</li>\n<li>数据4：104个随机整数；</li>\n<li>数据5：105个随机整数；</li>\n</ul>\n<h5 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>​    输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p>\n<h5 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式:\"></a>输出格式:</h5><p>​    在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>\n<h5 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例:\"></a>输入样例:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">-2</span> <span class=\"number\">11</span> <span class=\"number\">-4</span> <span class=\"number\">13</span> <span class=\"number\">-5</span> <span class=\"number\">-2</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例:\"></a>输出样例:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[MAXSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; number; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubSum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = maxSubSum(a, number);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, max);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在线处理，即时处理算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubSum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.定义当前循环子列和ThisSum,和整个最大值MaxSum</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ThisSum = <span class=\"number\">0</span>, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">// 2.从0遍历至N-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.ThisSum向右累加</span></span><br><span class=\"line\">        ThisSum += A[i];</span><br><span class=\"line\">        <span class=\"comment\">// 4.如果本次累加使得ThisSum比MaxSum更大，则更新MaxSum</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">            MaxSum = ThisSum;</span><br><span class=\"line\">            <span class=\"comment\">// 5.如果当前子列和ThisSum为负，ThisSum置0开始下一轮计算</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>定义当前循环子列和ThisSum,和整个最大值MaxSum</li>\n<li>从0遍历至N-1</li>\n<li>ThisSum向右累加</li>\n<li>如果本次累加使得ThisSum比MaxSum更大，则更新MaxSum</li>\n<li>如果当前子列和ThisSum为负，ThisSum置0开始下一轮计算</li>\n</ol>\n","categories":["PTA"],"tags":["复杂度"]},{"title":"02-线性结构2 一元多项式的乘法与加法运算","url":"/2021/07/24/02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/","content":"<p>设计函数分别求两个一元多项式的乘积与和。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式:\"></a>输出格式:</h4><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>\n<h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例:\"></a>输入样例:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">-5</span> <span class=\"number\">2</span>  <span class=\"number\">6</span> <span class=\"number\">1</span>  <span class=\"number\">-2</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">20</span>  <span class=\"number\">-7</span> <span class=\"number\">4</span>  <span class=\"number\">3</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例:\"></a>输出样例:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">15</span> <span class=\"number\">24</span> <span class=\"number\">-25</span> <span class=\"number\">22</span> <span class=\"number\">30</span> <span class=\"number\">21</span> <span class=\"number\">-10</span> <span class=\"number\">20</span> <span class=\"number\">-21</span> <span class=\"number\">8</span> <span class=\"number\">35</span> <span class=\"number\">6</span> <span class=\"number\">-33</span> <span class=\"number\">5</span> <span class=\"number\">14</span> <span class=\"number\">4</span> <span class=\"number\">-15</span> <span class=\"number\">3</span> <span class=\"number\">18</span> <span class=\"number\">2</span> <span class=\"number\">-6</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">20</span> <span class=\"number\">-4</span> <span class=\"number\">4</span> <span class=\"number\">-5</span> <span class=\"number\">2</span> <span class=\"number\">9</span> <span class=\"number\">1</span> <span class=\"number\">-2</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"多项式结构-PolyNode-Polynomial\"><a href=\"#多项式结构-PolyNode-Polynomial\" class=\"headerlink\" title=\"多项式结构 PolyNode - Polynomial\"></a>多项式结构 PolyNode - Polynomial</h4><ol>\n<li>系数coef</li>\n<li>指数expo</li>\n<li>下一结点link</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolyNode</span> *<span class=\"title\">Polynomial</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolyNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.系数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> coef;</span><br><span class=\"line\">    <span class=\"comment\">// 2.指数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> expo;</span><br><span class=\"line\">    <span class=\"comment\">// 3.下一结点</span></span><br><span class=\"line\">    Polynomial link;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">ReadPoly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> e, Polynomial *pRear)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintPoly</span><span class=\"params\">(Polynomial P)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">AddPoly</span><span class=\"params\">(Polynomial P1, Polynomial P2)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">MultiPoly</span><span class=\"params\">(Polynomial P1, Polynomial P2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Polynomial P1, P2, PP, PS;</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取输入的多项式P1</span></span><br><span class=\"line\">    P1 = ReadPoly();</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取输入的多项式P2</span></span><br><span class=\"line\">    P2 = ReadPoly();</span><br><span class=\"line\">    <span class=\"comment\">// 3.多项式P1与P2相乘得PS</span></span><br><span class=\"line\">    PS = MultiPoly(P1, P2);</span><br><span class=\"line\">    PrintPoly(PS);</span><br><span class=\"line\">    <span class=\"comment\">// 4.多项式P1与P2相乘得PP</span></span><br><span class=\"line\">    PP = AddPoly(P1, P2);</span><br><span class=\"line\">    PrintPoly(PP);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">MultiPoly</span><span class=\"params\">(Polynomial P1, Polynomial P2)</span> </span>&#123;</span><br><span class=\"line\">    Polynomial P, Rear, t1, t2, t;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c,e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!P1 || !P2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建新链表P，存放新的多项式</span></span><br><span class=\"line\">    P = (Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct PolyNode));</span><br><span class=\"line\">    Rear = P;</span><br><span class=\"line\">    t1 = P1;</span><br><span class=\"line\">    t2 = P2;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历t2,将t1第一个元素乘以t2中的所有元素，得到新链表P的第1个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t2) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.指数相加，系数相乘</span></span><br><span class=\"line\">        Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expo + t2-&gt;expo, &amp;Rear);</span><br><span class=\"line\">        t2 = t2-&gt;link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.将链表t1第二个元素之后的所有元素与链表t2中的元素互乘</span></span><br><span class=\"line\">    t1 = t1-&gt;link;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t1)&#123;</span><br><span class=\"line\">        t2 = P2;</span><br><span class=\"line\">        Rear = P;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t2)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5.指数相加，系数相乘</span></span><br><span class=\"line\">            e = t1-&gt;expo + t2-&gt;expo;</span><br><span class=\"line\">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class=\"line\">            <span class=\"comment\">// 6.将Rear定位到P链表中指数小于e之后</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expo &gt; e) &#123;</span><br><span class=\"line\">                Rear = Rear-&gt;link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 7.定位到多项式系数相等的结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expo == e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 8.还需要判断系数相加后是否为0，为0需要移除该结点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Rear-&gt;link-&gt;coef + c)&#123;</span><br><span class=\"line\">                    Rear-&gt;link-&gt;coef += c;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    t = Rear-&gt;link;</span><br><span class=\"line\">                    Rear-&gt;link = t-&gt;link;</span><br><span class=\"line\">                    <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 9.如果多项式指数不相等，生成新的结点将新的指数、系数写入结点t</span></span><br><span class=\"line\"><span class=\"comment\">//                Attach(c, e, &amp;Rear);</span></span><br><span class=\"line\">                t = (Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct PolyNode));</span><br><span class=\"line\">                t-&gt;coef = c;</span><br><span class=\"line\">                t-&gt;expo = e;</span><br><span class=\"line\">                <span class=\"comment\">// 10.将新结点t插入链表的尾部,尾指针Rear指向t</span></span><br><span class=\"line\">                t-&gt;link = Rear-&gt;link;</span><br><span class=\"line\">                Rear-&gt;link = t;</span><br><span class=\"line\">                Rear = Rear-&gt;link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 11. 链表t2指向下一结点</span></span><br><span class=\"line\">            t2 = t2-&gt;link;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 12.链表t1指向下一结点</span></span><br><span class=\"line\">        t1 = t1-&gt;link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Rear-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    t2 = P;</span><br><span class=\"line\">    <span class=\"comment\">// 13.释放链表P的空的头结点</span></span><br><span class=\"line\">    P = P-&gt;link;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(t2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">AddPoly</span><span class=\"params\">(Polynomial P1, Polynomial P2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (P1 == <span class=\"literal\">NULL</span> &amp;&amp; P2 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Polynomial front, rear, temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum, result;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建新的链表rear</span></span><br><span class=\"line\">    rear = (Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct PolyNode));</span><br><span class=\"line\">    front = rear;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历链表P1,P2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(P1 &amp;&amp; P2) &#123;</span><br><span class=\"line\">        result = P1-&gt;expo - P2-&gt;expo;</span><br><span class=\"line\">        <span class=\"comment\">// 3.比较P1，P2结点指数，将较小者插入链表尾部</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Attach(P1-&gt;coef, P1-&gt;expo, &amp;rear);</span><br><span class=\"line\">            P1 = P1-&gt;link;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Attach(P2-&gt;coef, P2-&gt;expo, &amp;rear);</span><br><span class=\"line\">            P2 = P2-&gt;link;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.如果两结点的指数相等，两结点相加</span></span><br><span class=\"line\">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class=\"line\">            <span class=\"comment\">// 5.如果系数不为0，将新结点插入rear尾部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum) &#123;</span><br><span class=\"line\">                Attach(sum, P1-&gt;expo, &amp;rear);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 6.链表P1,P2指向下一个结点</span></span><br><span class=\"line\">            P1 = P1-&gt;link;</span><br><span class=\"line\">            P2 = P2-&gt;link;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 7.处理未对比完成的剩余段</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;P1;P1=P1-&gt;link)Attach(P1-&gt;coef, P1-&gt;expo, &amp;rear);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;P2;P2=P2-&gt;link)Attach(P2-&gt;coef, P2-&gt;expo, &amp;rear);</span><br><span class=\"line\">    rear-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    temp = front;</span><br><span class=\"line\">    <span class=\"comment\">// 8.释放链表rear的空的头结点</span></span><br><span class=\"line\">    front = front-&gt;link;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(temp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Polynomial <span class=\"title\">ReadPoly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N, e, c;</span><br><span class=\"line\">    Polynomial P, Rear, t;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请多项式临时结点P，方便链表尾部插入新结点</span></span><br><span class=\"line\">    P = (Polynomial) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct PolyNode));</span><br><span class=\"line\">    P-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Rear = P;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (N--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.读取多项式的系数与指数，并插入链表P的尾部</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;c, &amp;e);</span><br><span class=\"line\">        Attach(c, e, &amp;Rear);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t = P;</span><br><span class=\"line\">    <span class=\"comment\">// 3.删除临时生成的头结点P</span></span><br><span class=\"line\">    P = P-&gt;link;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> e, Polynomial *pRear)</span> </span>&#123;</span><br><span class=\"line\">    Polynomial P;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请多项式结点，并插入pRear尾结点</span></span><br><span class=\"line\">    P = (Polynomial) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct PolyNode));</span><br><span class=\"line\">    P-&gt;coef = c;</span><br><span class=\"line\">    P-&gt;expo = e;</span><br><span class=\"line\">    P-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    (*pRear)-&gt;link = P;</span><br><span class=\"line\">    <span class=\"comment\">// 2.修改的pRear的值，指向刚创建的结点P</span></span><br><span class=\"line\">    *pRear = P;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintPoly</span><span class=\"params\">(Polynomial P)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!P) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0 0\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (P) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, P-&gt;coef, P-&gt;expo);</span><br><span class=\"line\">        P = P-&gt;link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h4><ol>\n<li>链表尾插入，可以先创建空的头结点方便操作，最后再释放头结点</li>\n<li>链表尾插入，需要定义尾指针Rear，新结点插入完成后，Rear指向新结点</li>\n</ol>\n","categories":["PTA"],"tags":["线性结构"]},{"title":"02-线性结构1 两个有序链表序列的合并","url":"/2021/07/24/02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6/","content":"<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列</p>\n<h4 id=\"函数接口定义：\"><a href=\"#函数接口定义：\" class=\"headerlink\" title=\"函数接口定义：\"></a>函数接口定义：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List <span class=\"title\">Merge</span><span class=\"params\">( List L1, List L2 )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>其中<code>List</code>结构定义如下：</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    ElementType Data; <span class=\"comment\">/* 存储结点数据 */</span></span><br><span class=\"line\">    PtrToNode   Next; <span class=\"comment\">/* 指向下一个结点的指针 */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List; <span class=\"comment\">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure>\n<p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p>\n<h4 id=\"裁判测试程序样例：\"><a href=\"#裁判测试程序样例：\" class=\"headerlink\" title=\"裁判测试程序样例：\"></a>裁判测试程序样例：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    PtrToNode   Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">Read</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* 细节在此不表 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">( List L )</span></span>; <span class=\"comment\">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">Merge</span><span class=\"params\">( List L1, List L2 )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    List L1, L2, L;</span><br><span class=\"line\">    L1 = Read();</span><br><span class=\"line\">    L2 = Read();</span><br><span class=\"line\">    L = Merge(L1, L2);</span><br><span class=\"line\">    Print(L);</span><br><span class=\"line\">    Print(L1);</span><br><span class=\"line\">    Print(L2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">8</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">8</span> <span class=\"number\">10</span> </span><br><span class=\"line\"><span class=\"literal\">NULL</span></span><br><span class=\"line\"><span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 合并两个递增的链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param L1</span></span><br><span class=\"line\"><span class=\"comment\"> * @param L2</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">Merge</span><span class=\"params\">(List L1, List L2)</span></span>&#123;</span><br><span class=\"line\">    List <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.构造空链表</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = (List)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct LNode));</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L1 == <span class=\"literal\">NULL</span> &amp;&amp; L2 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToLNode Temp1, Temp2, Position;</span><br><span class=\"line\">    Temp1 = L1-&gt;Next;</span><br><span class=\"line\">    Temp2 = L2-&gt;Next;</span><br><span class=\"line\">    <span class=\"comment\">// 添加一个位置指针，指向list的最后一元素，以便新增新结点</span></span><br><span class=\"line\">    Position = <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 原有链表指向NULL</span></span><br><span class=\"line\">    L1-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    L2-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历两个链表直至有空结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(Temp1 &amp;&amp; Temp2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = Temp1-&gt;Data - Temp2-&gt;Data;</span><br><span class=\"line\">        <span class=\"comment\">// 3.循环比较两个链表中的结点的大小，将较小结点插入新链表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result &lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// list的最后一个结点的Next指向temp1</span></span><br><span class=\"line\">            Position-&gt;Next = Temp1;</span><br><span class=\"line\">            <span class=\"comment\">// 最后元素的指针向后移到Temp1</span></span><br><span class=\"line\">            Position = Temp1;</span><br><span class=\"line\">            Temp1 = Temp1-&gt;Next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Position-&gt;Next = Temp2;</span><br><span class=\"line\">            Position = Temp2;</span><br><span class=\"line\">            Temp2 = Temp2-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.遍历链表List1或List2剩下的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;Temp1;Temp1=Temp1-&gt;Next)&#123;</span><br><span class=\"line\">        Position-&gt;Next = Temp1;</span><br><span class=\"line\">        Position = Temp1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;Temp2;Temp2=Temp2-&gt;Next) &#123;</span><br><span class=\"line\">        Position-&gt;Next = Temp2;</span><br><span class=\"line\">        Position = Temp2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>构造空链表list</li>\n<li>遍历两个链表直至有空结点</li>\n<li>循环比较两个链表中的结点的大小，将较小结点插入新链表</li>\n<li>遍历链表List1或List2剩下的结点</li>\n</ol>\n","categories":["PTA"],"tags":["线性结构"]},{"title":"02-线性结构4 Pop Sequence","url":"/2021/07/24/02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-Pop-Sequence/","content":"<p>​    Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>\n<a id=\"more\"></a>\n\n<h4 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h4><p>​    Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>\n<h4 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h4><p>​    For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>\n<h4 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">7</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"number\">1</span> <span class=\"number\">7</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">6</span> <span class=\"number\">5</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">7</span> <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">7</span> <span class=\"number\">6</span> <span class=\"number\">5</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n<h4 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h4><ul>\n<li>本解法主要思路为逆向放置</li>\n<li>即将测试用例中的数从最后一个开始放置</li>\n<li>如果能在一定容量的堆栈下输出N~1</li>\n<li>将放与取操作取反,即可满足题意</li>\n</ul>\n<h4 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//本解法主要思路为逆向放置</span></span><br><span class=\"line\"><span class=\"comment\">//即将测试用例中的数从最后一个开始放置</span></span><br><span class=\"line\"><span class=\"comment\">//如果能在一定容量的堆栈下输出N~1</span></span><br><span class=\"line\"><span class=\"comment\">//将放与取操作取反</span></span><br><span class=\"line\"><span class=\"comment\">//即可满足题意</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_p3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> M,N,K;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target;</span><br><span class=\"line\">    <span class=\"comment\">// 1.用数组表示堆栈存储元素,top为栈顶指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[<span class=\"number\">1001</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取堆栈容量M,顺序数字N,测试序列K</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;M,&amp;N,&amp;K);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b[N];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n ;</span><br><span class=\"line\">    <span class=\"comment\">// 3.重复读取K组序列</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(K--)&#123;</span><br><span class=\"line\">        target = N;</span><br><span class=\"line\">        top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        n = N;</span><br><span class=\"line\">        <span class=\"comment\">// 4.读取一组测试序列，存放在数组b中</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;b[N-n]);</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n = N<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//5.依次将数组b中的元素压入堆栈data中</span></span><br><span class=\"line\">            top++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(top &gt;= M)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data[top] = b[n];</span><br><span class=\"line\">            <span class=\"comment\">// 6.如果</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(data[top] == target&amp;&amp;top &gt;<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                target--;</span><br><span class=\"line\">                <span class=\"comment\">//printf(&quot;%d&quot;,top);</span></span><br><span class=\"line\">                top--;</span><br><span class=\"line\">                <span class=\"comment\">// printf(&quot;%d&quot;,top);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;%d&quot;,top);</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;%d&quot;,target);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(top == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(K != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["PTA"],"tags":["线性结构"]},{"title":"03-树3 Tree Traversals Again","url":"/2021/07/24/03-%E6%A0%913%20Tree%20Traversals%20Again/","content":"<p>​    An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/20151020162946653.png\" alt=\"20151020162946653\"></p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<h5 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">Push <span class=\"number\">1</span></span><br><span class=\"line\">Push <span class=\"number\">2</span></span><br><span class=\"line\">Push <span class=\"number\">3</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br><span class=\"line\">Push <span class=\"number\">4</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br><span class=\"line\">Push <span class=\"number\">5</span></span><br><span class=\"line\">Push <span class=\"number\">6</span></span><br><span class=\"line\">Pop</span><br><span class=\"line\">Pop</span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">2</span> <span class=\"number\">6</span> <span class=\"number\">5</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><p>​    从堆栈实现二叉树非递归遍历算法可知，入栈操作是先序遍历的顺序，而出栈操作则是中序遍历操作的顺序，需要输出后序遍历的顺序；所以需要根据push和pop构造出先序数组和中序数组，再利用递归算法依次找到根结点左右两边各元素的顺序。</p>\n<h5 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 50</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *in, *pre, *post, number;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PtrToSNode <span class=\"title\">CreateStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    PtrToSNode temp;</span><br><span class=\"line\">    temp = (PtrToSNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    temp-&gt;top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(PtrToSNode s, <span class=\"keyword\">int</span> item)</span> </span>&#123;</span><br><span class=\"line\">    s-&gt;data[++(s-&gt;top)] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Pop</span><span class=\"params\">(PtrToSNode s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s-&gt;data[(s-&gt;top)--];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestroyStack</span><span class=\"params\">(PtrToSNode s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据输入数据创建先序数组pre和中序数组in</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Input</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, n, value, indexPush = <span class=\"number\">0</span>, indexPop = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *s;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> temp[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建堆栈Stack</span></span><br><span class=\"line\">    PtrToSNode Stack = CreateStack();</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取共有多少数字number</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    n = number * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3.根据输入的number创建pre,in,post数组</span></span><br><span class=\"line\">    in = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    pre = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    post = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    <span class=\"comment\">// 4.根据输入的数据，读取push或pop操作，小于number*2</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5.读取字符串temp</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, temp);</span><br><span class=\"line\">        <span class=\"comment\">// 6.字符串是否包含字符h</span></span><br><span class=\"line\">        s = <span class=\"built_in\">strchr</span>(temp, <span class=\"string\">&#x27;h&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果包含，则继续读取数值value</span></span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;value);</span><br><span class=\"line\">            <span class=\"comment\">// 8.将读取到数值存入数组pre，并压入堆栈Stack</span></span><br><span class=\"line\">            pre[indexPush] = value;</span><br><span class=\"line\">            Push(Stack, value);</span><br><span class=\"line\">            indexPush++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 9.如果不包含字符h,则弹栈，将值存入数组in</span></span><br><span class=\"line\">            in[indexPop] = Pop(Stack);</span><br><span class=\"line\">            indexPop++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 10.释放堆栈Stack</span></span><br><span class=\"line\">    DestroyStack(Stack);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据先序、中序获取后序数组post</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetPost</span><span class=\"params\">(<span class=\"keyword\">int</span> preL, <span class=\"keyword\">int</span> inL, <span class=\"keyword\">int</span> postL, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果在数组外，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果数组最后只有一个元素时，直接将先序值赋值给后序对应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        post[postL] = pre[preL];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> root, i, lenL, lenR;</span><br><span class=\"line\">    <span class=\"comment\">// 3.数组长度大于1时，将先序pre的第1个元素即为根结点</span></span><br><span class=\"line\">    root = pre[preL];</span><br><span class=\"line\">    <span class=\"comment\">// 4.将根结点的值赋值给post数组的最末位</span></span><br><span class=\"line\">    post[postL + len - <span class=\"number\">1</span>] = root;</span><br><span class=\"line\">    <span class=\"comment\">// 5.遍历找到根结点root在中序数组in中的位置i</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (in[inL + i] == root)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 6.根结点root的左子树部分长度即为i, 右子树长度为len-i-1（根结点）</span></span><br><span class=\"line\">    lenL = i;</span><br><span class=\"line\">    lenR = len - lenL - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 7.递归求左子树部分, 先序指针右移1位, 数组为左子树部分lenL</span></span><br><span class=\"line\">    GetPost(preL + <span class=\"number\">1</span>, inL, postL, lenL);</span><br><span class=\"line\">    <span class=\"comment\">// 8.递归求右子树部分, 先序、中序、后序指针移至根结点右边，数组长度不右子树部分lenR</span></span><br><span class=\"line\">    GetPost(preL + lenL + <span class=\"number\">1</span>, inL + lenL + <span class=\"number\">1</span>, postL + lenL, lenR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printPost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; number; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == number - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, post[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, post[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Input();</span><br><span class=\"line\">    GetPost(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, number);</span><br><span class=\"line\">    printPost();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>在构造先序数组和中序数组时，用strchr(temp, ‘h’)函数判断字符串中是否包含字符h，包含返回具体的地址，不包含返回NULL；</li>\n<li>先序数组的第1个元素为后序数组的最后一个元素，即为根结点，如何根据这个条件写递归函数；</li>\n<li>构造的递归函数的边界条件，如len=0，len=1，如何确定？</li>\n</ol>\n","categories":["PTA"],"tags":["树","树习题"]},{"title":"04-树6 Complete Binary Search Tree","url":"/2021/07/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree/","content":"<p>​    A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>​    A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>\n<p>​    Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>\n<h5 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span> <span class=\"number\">3</span> <span class=\"number\">8</span> <span class=\"number\">1</span> <span class=\"number\">5</span> <span class=\"number\">7</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">2</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析:\"></a>分析:</h5><p>二叉搜索树：左子树 &lt; 根结点 &lt; 右子树；</p>\n<p>完全二叉树：元素依次从上到下，从左到右顺序存储；</p>\n<p>完全二叉搜索树即包含以上两者的特性。</p>\n<p>根据元素个数构造完全二叉树结构，用数组顺序存储，将原来的数组按从小到大排序得到有序数组；根据完全二叉树结构可以定位到比根结点小的元素个数L，及比根结点大的元素个数，所以根结点的值为有序数组中的第L个，依次分段处理根结点的左部分、右部分。</p>\n<h5 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h5><ol>\n<li>读取数组个数及数组元素</li>\n<li>对数组进行排序</li>\n<li>获取完全二叉搜索树GetBinTree</li>\n<li>打印新的数组</li>\n</ol>\n<h5 id=\"获取完全二叉搜索树-递归GetBinTree\"><a href=\"#获取完全二叉搜索树-递归GetBinTree\" class=\"headerlink\" title=\"获取完全二叉搜索树,递归GetBinTree\"></a>获取完全二叉搜索树,递归GetBinTree</h5><ol>\n<li>判断是否到达递归的边界，即左边到达右边或右边越过左边</li>\n<li>计算根结点左边有多长GetLeftLength</li>\n<li>从有序数组Arr中找的第ALeft+L个元素即为Bin数组的根结点</li>\n<li>计算当前根结点的左孩子和右孩子</li>\n<li>递归获取以根结点为界的左部分、右部分的新的根结点</li>\n</ol>\n<h5 id=\"获取当前根结点的左子树的长度GetLeftLength\"><a href=\"#获取当前根结点的左子树的长度GetLeftLength\" class=\"headerlink\" title=\"获取当前根结点的左子树的长度GetLeftLength\"></a>获取当前根结点的左子树的长度GetLeftLength</h5><ol>\n<li>求出n个结点为满二叉树的树高</li>\n<li>求出最底层树结点的个数</li>\n<li>求最底层结点属于左子树部分的个数</li>\n<li>求得根结点左子树部分长度</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 完全二叉搜索树 CBST(CST + BST)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10001</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *Arr;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *Bin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用比较排序O(N^2)复杂度，但代码简单</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SortArray</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Arr[i] &gt; Arr[j]) &#123;</span><br><span class=\"line\">                temp = Arr[i];</span><br><span class=\"line\">                Arr[i] = Arr[j];</span><br><span class=\"line\">                Arr[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前根结点的左子树的长度，左子树也为完全二叉树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLeftLength</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 满二叉树高h, 最底层结点数x, 左子树长度l</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h, x, l;</span><br><span class=\"line\">    <span class=\"comment\">// 1.求出n个结点为满二叉树的树高</span></span><br><span class=\"line\">    h = (<span class=\"keyword\">int</span>) log2(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2.求出最底层树结点的个数</span></span><br><span class=\"line\">    x = n + <span class=\"number\">1</span> - <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, h);</span><br><span class=\"line\">    <span class=\"comment\">// 3.求最底层结点属于左子树部分的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, h - <span class=\"number\">1</span>) &lt; x) &#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, h - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.求得根结点左子树部分长度</span></span><br><span class=\"line\">    l = <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, h - <span class=\"number\">1</span>) - <span class=\"number\">1</span> + x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取完全二叉搜索树,递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetBinTree</span><span class=\"params\">(<span class=\"keyword\">int</span> ALeft, <span class=\"keyword\">int</span> ARight, <span class=\"keyword\">int</span> TRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, L, LeftTRoot, RightTRoot;</span><br><span class=\"line\">    n = ARight - ALeft + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断是否到达递归的边界，即左边到达右边或右边越过左边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.计算根结点左边有多长</span></span><br><span class=\"line\">    L = GetLeftLength(n);</span><br><span class=\"line\">    <span class=\"comment\">// 3.从有序数组Arr中找的第ALeft+L个元素即为Bin数组的根结点</span></span><br><span class=\"line\">    Bin[TRoot] = Arr[ALeft + L];</span><br><span class=\"line\">    <span class=\"comment\">// 4.计算当前根结点的左孩子和右孩子</span></span><br><span class=\"line\">    LeftTRoot = TRoot * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    RightTRoot = LeftTRoot + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 5.递归获取以根结点为界的左部分、右部分的新的根结点</span></span><br><span class=\"line\">    GetBinTree(ALeft, ALeft + L - <span class=\"number\">1</span>, LeftTRoot);</span><br><span class=\"line\">    GetBinTree(ALeft + L + <span class=\"number\">1</span>, ARight, RightTRoot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintArray</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == n - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, arr[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    Arr = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    Bin = (<span class=\"keyword\">int</span> *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n);</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取数组个数及数组元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.对数组进行排序</span></span><br><span class=\"line\">    SortArray(n);</span><br><span class=\"line\">    <span class=\"comment\">// 3.获取完全二叉搜索树</span></span><br><span class=\"line\">    GetBinTree(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 4.打印新的数组</span></span><br><span class=\"line\">    PrintArray(Bin, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>熟悉二叉搜索树、完全二叉树结构特性；</li>\n<li>从特殊个例到全体通用，构造递归函数。</li>\n</ol>\n","categories":["PTA"],"tags":["树","树习题"]},{"title":"03-树2 List Leaves","url":"/2021/07/26/03-%E6%A0%912-List-Leaves/","content":"<p>​    Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p>\n<h4 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h4><p>​    Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p>\n<a id=\"more\"></a>\n\n<h4 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h4><p>​    For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>\n<h4 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">1</span> -</span><br><span class=\"line\">- -</span><br><span class=\"line\"><span class=\"number\">0</span> -</span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">7</span></span><br><span class=\"line\">- -</span><br><span class=\"line\">- -</span><br><span class=\"line\"><span class=\"number\">5</span> -</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">1</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"结构-TreeNode数组\"><a href=\"#结构-TreeNode数组\" class=\"headerlink\" title=\"结构 TreeNode数组\"></a>结构 TreeNode数组</h4><ol>\n<li>结点值Element</li>\n<li>左子树</li>\n<li>右子树</li>\n<li>结点数组T1用于存放输入的数据，T2存放层序遍历的数据</li>\n</ol>\n<h4 id=\"生成二叉树-CreateBiTree\"><a href=\"#生成二叉树-CreateBiTree\" class=\"headerlink\" title=\"生成二叉树 CreateBiTree\"></a>生成二叉树 CreateBiTree</h4><ol>\n<li>输入结点数</li>\n<li>check数组用来判断根的位置,check[i]初始化为0</li>\n<li>读取N个结点的左、右孩子</li>\n<li>如果读取的非‘-’数据则写入左子树,同时check标记该点有子树，读空则为Null</li>\n<li>如果读取非’-‘数据则写入右子树，同时check标记该点有子树，读入空则为Null</li>\n<li>写入结点的值i</li>\n<li>如果左右都为’-‘，叶子数leves加1</li>\n<li>遍历标记数组，index的值check为0，则说明该点无父结点，是根结点</li>\n</ol>\n<h4 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h4><ol>\n<li>创建二叉树，返回根结点及叶子数</li>\n<li>将根结点添加到T2数组的第1个位置</li>\n<li>遍历数组，直到头、尾指针相同</li>\n<li>取出队列头结点FirstCell</li>\n<li>如果左、右子树都为空，则打针叶子结点</li>\n<li>如果头结点FirstCell的左子树不空，加入左子树到队列中</li>\n<li>如果头结点FirstCell的右子树不空，加入右子树到队列中</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxTree 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ElementType int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tree int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Null -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> <span class=\"title\">PtrToTNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点值</span></span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    <span class=\"comment\">// 2.左子树</span></span><br><span class=\"line\">    Tree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.右子树</span></span><br><span class=\"line\">    Tree Right;</span><br><span class=\"line\">&#125; T1[MaxTree], T2[MaxTree];</span><br><span class=\"line\"><span class=\"comment\">// 4.结点数组T1用于存放输入的数据，T2存放层序遍历的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Tree <span class=\"title\">CreateBiTree</span><span class=\"params\">(struct TreeNode T[], <span class=\"keyword\">int</span> *leaves)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Tree R1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Front, Rear, LeavesNub;</span><br><span class=\"line\">    PtrToTNode FirstCell;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建二叉树，返回根结点及叶子数</span></span><br><span class=\"line\">    R1 = CreateBiTree(T1, &amp;LeavesNub);</span><br><span class=\"line\">    Front = Rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.将根结点添加到T2数组的第1个位置</span></span><br><span class=\"line\">    T2[Rear++] = T1[R1];</span><br><span class=\"line\">    <span class=\"comment\">// 3.遍历数组，直到头、尾指针相同</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Rear != Front) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4.取出队列头结点FirstCell</span></span><br><span class=\"line\">        FirstCell = T2[Front++];</span><br><span class=\"line\">        <span class=\"comment\">// 5.如果左、右子树都为空，则打针叶子结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (FirstCell.Right == Null &amp;&amp; FirstCell.Left == Null) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LeavesNub != <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, FirstCell.Element);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, FirstCell.Element);</span><br><span class=\"line\">            LeavesNub--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.如果头结点FirstCell的左子树不空，加入左子树到队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (FirstCell.Left != Null) &#123;</span><br><span class=\"line\">            T2[Rear++] = T1[FirstCell.Left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 7.如果头结点FirstCell的右子树不空，加入右子树到队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (FirstCell.Right != Null) &#123;</span><br><span class=\"line\">            T2[Rear++] = T1[FirstCell.Right];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从输入的数据中生成二叉树，保存在结构体数组中</span></span><br><span class=\"line\"><span class=\"comment\"> * @param T  元素&#123;index left right&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * @param leaves 统计叶子总数，用于控制输出格式</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Tree <span class=\"title\">CreateBiTree</span><span class=\"params\">(struct TreeNode T[], <span class=\"keyword\">int</span> *leaves)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, N, check[MaxTree];</span><br><span class=\"line\">    Tree Root = Null;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> cl, cr;</span><br><span class=\"line\">    <span class=\"comment\">// 1.输入结点数</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, &amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//2.check数组用来判断根的位置,check[i]初始化为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">            check[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        *leaves = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 3.读取N个结点的左、右孩子</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c %c\\n&quot;</span>, &amp;cl, &amp;cr);</span><br><span class=\"line\">            <span class=\"comment\">// 4.如果读取的非‘-’数据则写入左子树,同时check标记该点有子树，读空则为Null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cl != <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">                T[i].Left = cl - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">                check[T[i].Left] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                T[i].Left = Null;</span><br><span class=\"line\">            <span class=\"comment\">// 5.如果读取非&#x27;-&#x27;数据则写入右子树，同时check标记该点有子树，读入空则为Null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cr != <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">                T[i].Right = cr - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">                check[T[i].Right] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                T[i].Right = Null;</span><br><span class=\"line\">            <span class=\"comment\">// 6.写入结点的值</span></span><br><span class=\"line\">            T[i].Element = i;</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果左右都为&#x27;-&#x27;，叶子数leves加1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cl == <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; cr == <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">                (*leaves)++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//8.遍历标记数组，index的值check为0，则说明该点无父结点，是根结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!check[i]) &#123;</span><br><span class=\"line\">                Root = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h4><ol>\n<li>数据结构选择，采用结构体数组2个，一个用于存储输入数据，一个用于层序遍历输出</li>\n<li>层序遍历需要使用队列，则需要头、尾指针(Front,Rear)</li>\n<li>为满足输出格式，加入叶子结点数指针变量LeavesNub</li>\n</ol>\n","categories":["PTA"],"tags":["树","树习题"]},{"title":"05-树8 File Transfer","url":"/2021/07/26/05-%E6%A0%918-File-Transfer/","content":"<p>​    We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>\n<h4 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h4><p>​    Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">I c1 c2 </span><br></pre></td></tr></table></figure>\n<p>​    where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">C c1 c2    </span><br></pre></td></tr></table></figure>\n<p>​    where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">S</span><br></pre></td></tr></table></figure>\n<p>​    where <code>S</code> stands for stopping this case.</p>\n<h4 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h4><p>​    For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p>\n<h4 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input 1:\"></a>Sample Input 1:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">C <span class=\"number\">3</span> <span class=\"number\">2</span></span><br><span class=\"line\">I <span class=\"number\">3</span> <span class=\"number\">2</span></span><br><span class=\"line\">C <span class=\"number\">1</span> <span class=\"number\">5</span></span><br><span class=\"line\">I <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">I <span class=\"number\">2</span> <span class=\"number\">4</span></span><br><span class=\"line\">C <span class=\"number\">3</span> <span class=\"number\">5</span></span><br><span class=\"line\">S</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output 1:\"></a>Sample Output 1:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">no</span><br><span class=\"line\">no</span><br><span class=\"line\">yes</span><br><span class=\"line\">There are <span class=\"number\">2</span> components.</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input 2:\"></a>Sample Input 2:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">C <span class=\"number\">3</span> <span class=\"number\">2</span></span><br><span class=\"line\">I <span class=\"number\">3</span> <span class=\"number\">2</span></span><br><span class=\"line\">C <span class=\"number\">1</span> <span class=\"number\">5</span></span><br><span class=\"line\">I <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">I <span class=\"number\">2</span> <span class=\"number\">4</span></span><br><span class=\"line\">C <span class=\"number\">3</span> <span class=\"number\">5</span></span><br><span class=\"line\">I <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">C <span class=\"number\">1</span> <span class=\"number\">5</span></span><br><span class=\"line\">S</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output 2:\"></a>Sample Output 2:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">no</span><br><span class=\"line\">no</span><br><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">The network is connected.</span><br></pre></td></tr></table></figure>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>输入测试样例次数n,初始化数组S</li>\n<li>循环读取操作，根据不同字符进行不同操作</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;  <span class=\"comment\">//默认元素可以用非负整数表示</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> SetName;; <span class=\"comment\">// 默认用根结点的下标作为集合的名称</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> ElementType SetType[MAXSIZE];<span class=\"comment\">//各结点的父结点集合，根结点为负数，数值为树高</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialization</span><span class=\"params\">(SetType S, <span class=\"keyword\">int</span> N)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SetName <span class=\"title\">Find</span><span class=\"params\">(SetType S, ElementType X)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(SetType S, SetName Root1, SetName Root2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InputConnection</span><span class=\"params\">(SetType S)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckConnection</span><span class=\"params\">(SetType S)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckNetWork</span><span class=\"params\">(SetType S, <span class=\"keyword\">int</span> N)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   SetType S;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> in;</span><br><span class=\"line\">   <span class=\"comment\">// 1.输入测试样例次数n,初始化数组S</span></span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, &amp;n);</span><br><span class=\"line\">   Initialization(S, n);</span><br><span class=\"line\">   <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.循环读取操作，根据不同字符进行不同操作</span></span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;in);</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (in) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&#x27;I&#x27;</span>:</span><br><span class=\"line\">               InputConnection(S);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:</span><br><span class=\"line\">               CheckConnection(S);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> <span class=\"string\">&#x27;S&#x27;</span>:</span><br><span class=\"line\">               CheckNetWork(S, n);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">while</span> (in != <span class=\"string\">&#x27;S&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输入结点并联合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InputConnection</span><span class=\"params\">(SetType S)</span> </span>&#123;</span><br><span class=\"line\">    ElementType u, v;</span><br><span class=\"line\">    SetName Root1, Root2;</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取两个结点值u,v</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">    <span class=\"comment\">// 2.找到两个结点的根结点Root1,Root2</span></span><br><span class=\"line\">    Root1 = Find(S, u - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Root2 = Find(S, v - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 3.如果两根点不同，则两结点相结合</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Root1 != Root2)</span><br><span class=\"line\">        Union(S, Root1, Root2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查两点联通性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckConnection</span><span class=\"params\">(SetType S)</span> </span>&#123;</span><br><span class=\"line\">    ElementType u, v;</span><br><span class=\"line\">    SetName Root1, Root2;</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取两个结点值u,v</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, &amp;u, &amp;v);</span><br><span class=\"line\">    <span class=\"comment\">// 2.找到两个结点的根结点Root1,Root2</span></span><br><span class=\"line\">    Root1 = Find(S, u - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Root2 = Find(S, v - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 3.如果两结点相同，打印yes，不同打印no</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Root1 == Root2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;yes\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查整个网络联通性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckNetWork</span><span class=\"params\">(SetType S, <span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.遍历数组Set，检查所有结点的父结点，记录为负数的根结点数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            counter++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.根据不同的根结点数counter打印输出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (counter == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The network is connected.\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;There are %d components.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化结点数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialization</span><span class=\"params\">(SetType S, <span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        S[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找x结点的根结点</span></span><br><span class=\"line\"><span class=\"function\">SetName <span class=\"title\">Find</span><span class=\"params\">(SetType S, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.遍历数组S,直到找根结点,S[x]为负数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; S[X] &gt;= <span class=\"number\">0</span>; X = S[X]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> X;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 联合两棵树Root1,Root2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Union</span><span class=\"params\">(SetType S, SetName Root1, SetName Root2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Root1,Root2为不同集合的根结点,</span></span><br><span class=\"line\">    <span class=\"comment\">// 将根结点的值表示树的深度，负数表示为根结点</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.合并两树，树深度较小的并到深度较大的上，这样才不会增加树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S[Root2] &lt; S[Root1])</span><br><span class=\"line\">        <span class=\"comment\">// Root2的深度更大，需要将Root1并到Root2上</span></span><br><span class=\"line\">        S[Root1] = Root2;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果两树深度相同，则将Root2并到Root1上，Root1深度加1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (S[Root1] == S[Root2])</span><br><span class=\"line\">            S[Root1]--;</span><br><span class=\"line\">        S[Root2] = Root1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h4><ol>\n<li>各结点的父结点用数组SetType存储，初始化为-1，根结点无父结点为负值</li>\n<li>数组SetType，如果是根结点存负数，数值为树的高度</li>\n<li>判断根结点是否相同判断是否同一棵树</li>\n<li>树的高度较低者并在较高者上Union，减小查找根结点Find遍历的次数</li>\n</ol>\n","categories":["PTA"],"tags":["树","树习题"]},{"title":"06-图1 列出连通集","url":"/2021/07/26/06-%E5%9B%BE1-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/","content":"<p>​    给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h4><p>​    输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式:\"></a>输出格式:</h4><p>​    按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>\n<h4 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例:\"></a>输入样例:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例:\"></a>输出样例:</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">4</span> <span class=\"number\">2</span> <span class=\"number\">7</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"number\">3</span> <span class=\"number\">5</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"number\">6</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"number\">3</span> <span class=\"number\">5</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"number\">6</span> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>读入顶点数、边数</li>\n<li>构造图，插入边</li>\n<li>DFS搜索, 遍历所有结点</li>\n<li>重置visited标记位</li>\n<li>BFS搜索, 遍历所有结点</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxVertexNum 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Vertex;<span class=\"comment\">// 用整形表示顶点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> WeightType; <span class=\"comment\">// 权重</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> DataType;<span class=\"comment\">// 顶点数据，字符型</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> Visited[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode MGraph;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv; <span class=\"comment\">//顶点数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Ne; <span class=\"comment\">// 边数</span></span><br><span class=\"line\">    WeightType G[MaxVertexNum][MaxVertexNum];<span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\">    DataType Data[MaxVertexNum];<span class=\"comment\">//顶点数据，点的权重</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> *<span class=\"title\">PtrToENode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToENode Edge;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> &#123;</span></span><br><span class=\"line\">    Vertex V1, V2;<span class=\"comment\">//有向边&lt;v1,v2&gt;</span></span><br><span class=\"line\">    WeightType Weight; <span class=\"comment\">// 权重</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">PtrToQNode</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// 数组存放元素，最大容量为MaxSize-1，可重复存放元素</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">    Vertex *Data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front, rear;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToQNode Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span> </span>&#123;</span><br><span class=\"line\">   Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span> = (Queue) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data = (Vertex *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Vertex) * MaxSize);</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;rear == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AddQ</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, Vertex item)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsFull(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is full!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;rear] = item;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vertex <span class=\"title\">DeleteQ</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = (<span class=\"built_in\">queue</span>-&gt;front + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;front];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MGraph <span class=\"title\">CreateGraph</span><span class=\"params\">(<span class=\"keyword\">int</span> VertexNum, <span class=\"keyword\">int</span> EdgeNum)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个有VertexNum个顶点0条边的图</span></span><br><span class=\"line\">   Vertex V, W;</span><br><span class=\"line\">   MGraph Graph;</span><br><span class=\"line\">   Graph = (MGraph) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct GNode));</span><br><span class=\"line\">   Graph-&gt;Nv = VertexNum;</span><br><span class=\"line\">   Graph-&gt;Ne = EdgeNum;</span><br><span class=\"line\">   <span class=\"comment\">// 初始化二维数组</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">       Visited[V] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class=\"line\">           Graph-&gt;G[V][W] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertEdge</span><span class=\"params\">(MGraph Graph, Edge E)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 插入边&lt;v1,v2&gt;</span></span><br><span class=\"line\">   Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class=\"line\">   <span class=\"comment\">// 如果是无向图还需要插入反向点，对称矩阵</span></span><br><span class=\"line\">   Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MGraph <span class=\"title\">BuildGraph</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   MGraph Graph;</span><br><span class=\"line\">   Edge E;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> Nv, Ne, i;</span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;Nv, &amp;Ne);</span><br><span class=\"line\">   Graph = CreateGraph(Nv, Ne);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Graph-&gt;Ne != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       E = (Edge) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ENode));</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Ne; i++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 循环读入一条边,并插入Graph中</span></span><br><span class=\"line\">           <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2);</span><br><span class=\"line\">           E-&gt;Weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">           InsertEdge(Graph, E);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEdge</span><span class=\"params\">(MGraph Graph, Vertex V, Vertex W)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Graph-&gt;G[V][W] &lt;= <span class=\"number\">-1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(Vertex V)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, V);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(MGraph Graph, Vertex S, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">   Queue Q;</span><br><span class=\"line\">   Vertex V, W;</span><br><span class=\"line\">   Q = CreateQueue(MaxVertexNum);</span><br><span class=\"line\">   Visit(S);</span><br><span class=\"line\">   Visited[S] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   AddQ(Q, S);</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (!IsEmpty(Q)) &#123;</span><br><span class=\"line\">       V = DeleteQ(Q);</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 若W是V的邻接点并且未访问过 Graph-&gt;G[V][W]为-1表示v-w未连接，为1表示连接</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!Visited[W] &amp;&amp; Graph-&gt;G[V][W] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               Visit(W);</span><br><span class=\"line\">               Visited[W] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">               AddQ(Q, W);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph Graph, Vertex V, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 先访问结点v，并将标记置为true</span></span><br><span class=\"line\">   Visit(V);</span><br><span class=\"line\">   Visited[V] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   Vertex W;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//找到下一个与V点相交的点，同时该点未被访问</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Graph-&gt;G[V][W] &gt; <span class=\"number\">0</span> &amp;&amp; !Visited[W]) &#123;</span><br><span class=\"line\">           DFS(Graph, W, Visit);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.读入顶点数、边数</span></span><br><span class=\"line\">   <span class=\"comment\">// 2.构造图，插入边</span></span><br><span class=\"line\">   MGraph Graph = BuildGraph();</span><br><span class=\"line\">   <span class=\"comment\">// 3.DFS搜索, 遍历所有结点</span></span><br><span class=\"line\">   Vertex S;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (S = <span class=\"number\">0</span>; S &lt; Graph-&gt;Nv; S++) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!Visited[S]) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&#123; &quot;</span>);</span><br><span class=\"line\">           DFS(Graph, S, &amp;Visit);</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&#125;\\n&quot;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 4.重置visited标记位</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (S = <span class=\"number\">0</span>; S &lt; MaxVertexNum; S++) &#123;</span><br><span class=\"line\">       Visited[S] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.BFS搜索, 遍历所有结点</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (S = <span class=\"number\">0</span>; S &lt; Graph-&gt;Nv; S++) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!Visited[S]) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&#123; &quot;</span>);</span><br><span class=\"line\">           BFS(Graph, S, &amp;Visit);</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&#125;\\n&quot;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h4><ol>\n<li>图的结构用邻接矩阵还是邻接表？因为需要按顶点顺序输出，而邻接表插入边时并不是按顶点顺序插入，所以邻接表不适用(需要改造，按序插入边)，建议用邻接矩阵。</li>\n<li>DFS深度优先搜索完成后需要重置标记位visited，否则BFS无法访问</li>\n<li>注意顶点是从0开始计算还是从1开始</li>\n</ol>\n","categories":["PTA"],"tags":["图","图习题"]},{"title":"06-图2 Saving James Bond - Easy Version","url":"/2021/07/24/06-%E5%9B%BE2%20Saving%20James%20Bond%20-%20Easy%20Version/","content":"<p>​    This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/20171119150253795.png\" alt=\"20171119150253795\"></p>\n<p>​    Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>\n<h5 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h5><p>​    Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>\n<h5 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h5><p>​    For each test case, print in a line “Yes” if James can escape, or “No” if not.</p>\n<h5 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input 1:\"></a>Sample Input 1:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">14</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"number\">25</span> <span class=\"number\">-15</span></span><br><span class=\"line\"><span class=\"number\">-25</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">29</span> <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"number\">-35</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">27</span> <span class=\"number\">-29</span></span><br><span class=\"line\"><span class=\"number\">-8</span> <span class=\"number\">-28</span></span><br><span class=\"line\"><span class=\"number\">-20</span> <span class=\"number\">-35</span></span><br><span class=\"line\"><span class=\"number\">-25</span> <span class=\"number\">-20</span></span><br><span class=\"line\"><span class=\"number\">-13</span> <span class=\"number\">29</span></span><br><span class=\"line\"><span class=\"number\">-30</span> <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"number\">-35</span> <span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output 1:\"></a>Sample Output 1:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Yes</span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input 2:\"></a>Sample Input 2:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">-12</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">-12</span> <span class=\"number\">-12</span></span><br><span class=\"line\"><span class=\"number\">12</span> <span class=\"number\">-12</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output 2:\"></a>Sample Output 2:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">No</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><ol>\n<li>根据输入的鳄鱼条数N创建图中的坐标点，用结构体数组表示；</li>\n<li>根据当前坐标是否可以直接跳到安全的岸边IsSafe；</li>\n<li>遍历数组所有的点，判断哪些可以完成第一步跳跃FirstJump；</li>\n<li>完成第一跳后继续深度搜索DFS哪些点可以进行下一跳CanJump；</li>\n<li>输出是否存在安全跳到岸边的可能。</li>\n</ol>\n<h5 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码:\"></a>编码:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DIA 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIDE 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsSafe</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FirstJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index1, <span class=\"keyword\">int</span> index2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.恶鱼所在坐标数组A，最大为100</span></span><br><span class=\"line\"><span class=\"comment\">// 2.标记数组B，是否是访问过</span></span><br><span class=\"line\"><span class=\"comment\">// 3.恶鱼的条数N, 以及007跳跃的距离D</span></span><br><span class=\"line\"><span class=\"comment\">// 4.池塘边长SIDE为100，中间小岛半径DIA15</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125; A[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> B[MAXN], N, D;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.读取恶鱼的条数，以及007跳跃的距离D</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;N, &amp;D);</span><br><span class=\"line\">    <span class=\"comment\">// 2.读取各条恶鱼的坐标，存储在数组A中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;A[i].x, &amp;A[i].y);</span><br><span class=\"line\">    <span class=\"comment\">// 3.判断是否可以跳到岸边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsSafe(<span class=\"number\">-1</span>))</span><br><span class=\"line\">        flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4.如不能，则遍历恶鱼寻找可以第一步跳的恶鱼</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!B[i] &amp;&amp; FirstJump(i)) &#123;</span><br><span class=\"line\">                B[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 5.如果完成第一跳，继续深度搜索DFS</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (DFS(i))</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以跳到岸边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsSafe</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.是否为第一跳-1，小岛半径 + 跳跃距离 &gt; 边长</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">double</span>) DIA / <span class=\"number\">2</span> + D &gt;= (<span class=\"keyword\">double</span>) SIDE / <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非第一跳，当前坐标x或y+跳跃距离大于边长，说明成功</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = A[index].x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = A[index].y;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">abs</span>(x) + D &gt;= SIDE / <span class=\"number\">2</span>) || (<span class=\"built_in\">abs</span>(y) + D &gt;= SIDE / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以第一跳</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FirstJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.坐标x,y到圆心的距离distance</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> distance = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">pow</span>(A[index].x, <span class=\"number\">2</span>) + <span class=\"built_in\">pow</span>(A[index].y, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果跳跃距离 + 边长 &gt;= 半径distance，则为真</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (D + (<span class=\"keyword\">double</span>) DIA / <span class=\"number\">2</span> &gt;= distance);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否可以下一跳</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CanJump</span><span class=\"params\">(<span class=\"keyword\">int</span> index1, <span class=\"keyword\">int</span> index2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x1 = A[index1].x, y1 = A[index1].y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x2 = A[index2].x, y2 = A[index2].y;</span><br><span class=\"line\">    <span class=\"comment\">// 1.取index1,index2两点间的距离distance</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> distance = <span class=\"built_in\">sqrt</span>(<span class=\"built_in\">pow</span>(x1 - x2, <span class=\"number\">2</span>) + <span class=\"built_in\">pow</span>(y1 - y2, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果点距distance小于等于可跳跃的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> D &gt;= distance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深度搜索index</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断是否可以跳到岸边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsSafe(index))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历数组中所有的点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果点i未被访问过，且点i可以跳跃到，则继续下一跳DFS递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!B[i] &amp;&amp; CanJump(i, index)) &#123;</span><br><span class=\"line\">            B[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (DFS(i))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>所有鳄鱼坐标的结构选择，邻接矩阵，邻接表？这个是用结构体数组，或是二维数组；</li>\n<li>输入完所有坐标后，开始第一跳时，也需要判断是否可以直接跳到岸边；</li>\n<li>求几何运算，如平方、开方、绝对值等，用math库。</li>\n</ol>\n","categories":["PTA"],"tags":["图","图习题"]},{"title":"recyclerView使用小结(一)","url":"/2021/01/20/recyclerview_use1/","content":"<h3 id=\"recyclerView-Adapter主要方法及执行顺序\"><a href=\"#recyclerView-Adapter主要方法及执行顺序\" class=\"headerlink\" title=\"recyclerView.Adapter主要方法及执行顺序\"></a>recyclerView.Adapter主要方法及执行顺序</h3><ul>\n<li><p>recyclerview适配器Adapter中主要方法有构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法；</p>\n</li>\n<li><p>主要的方法的执行顺序为：构造方法 –&gt; getItemViewType –&gt; onCreateViewHolder –&gt; onBindViewHolder</p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\"><a href=\"#在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\" class=\"headerlink\" title=\"在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同\"></a>在同一个recyclerView中显示不同有UI并且每类UI的数据结构也不同</h3><h4 id=\"针对不同的数据结构，先创建数据的基类IBaseData-定义不的类型常量如TYPE-FIRST-1及默认类型TYPE-NULL-1，对外暴露获取类型的方法与获取数据T的方法；\"><a href=\"#针对不同的数据结构，先创建数据的基类IBaseData-定义不的类型常量如TYPE-FIRST-1及默认类型TYPE-NULL-1，对外暴露获取类型的方法与获取数据T的方法；\" class=\"headerlink\" title=\"针对不同的数据结构，先创建数据的基类IBaseData,定义不的类型常量如TYPE_FIRST=1及默认类型TYPE_NULL=-1，对外暴露获取类型的方法与获取数据T的方法；\"></a>针对不同的数据结构，先创建数据的基类<code>IBaseData</code>,定义不的类型常量如TYPE_FIRST=1及默认类型TYPE_NULL=-1，对外暴露获取类型的方法与获取数据T的方法；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBaseData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_NULL = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_FIRST = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TYPE_SECOND = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEntity</span><span class=\"params\">(T data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getEntity</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\"><a href=\"#新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\" class=\"headerlink\" title=\"新建类BaseDataImpl实现之前创建的数据基类IBaseData，通过构造方法传不同的数据类型的实例bean；\"></a>新建类<code>BaseDataImpl</code>实现之前创建的数据基类<code>IBaseData</code>，通过构造方法传不同的数据类型的实例bean；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseDataImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBaseData</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Object object;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseDataImpl</span><span class=\"params\">(Object object, <span class=\"keyword\">int</span> type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEntity</span><span class=\"params\">(Object data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getEntity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder-IBaseData-data-int-position-来调用adapter的根方法onBindViewHolder-BaseViewHolder-holder-int-position-，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\"><a href=\"#针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder-IBaseData-data-int-position-来调用adapter的根方法onBindViewHolder-BaseViewHolder-holder-int-position-，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\" class=\"headerlink\" title=\"针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过findViewById去查找使用子控件；关键方法是bindViewHolder(IBaseData data, int position)来调用adapter的根方法onBindViewHolder(BaseViewHolder holder, int position)，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；\"></a>针对不同的UI类型，创建所有viewHolder的基类BaseViewHolder，传入布局layoutId，统一创建当前类型的界面，再由不同子类通过<code>findViewById</code>去查找使用子控件；关键方法是<code>bindViewHolder(IBaseData data, int position)</code>来调用adapter的根方法<code>onBindViewHolder(BaseViewHolder holder, int position)</code>，这样就实现了不同界面的viewHolder处理不同界面的数据，各自不干扰；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseViewHolder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(inflateView(parent,layoutId));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> View <span class=\"title\">inflateView</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> View <span class=\"title\">findViewById</span><span class=\"params\">(<span class=\"keyword\">int</span> viewId)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> itemView.findViewById(viewId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">bindViewHolder</span><span class=\"params\">(IBaseData data, <span class=\"keyword\">int</span> position)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List-lt-BaseDataImpl-gt-界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder\"><a href=\"#新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List-lt-BaseDataImpl-gt-界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder\" class=\"headerlink\" title=\"新建recyclerView的adapter类MyAdapter，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以List&lt;BaseDataImpl&gt;界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder;\"></a>新建recyclerView的adapter类<code>MyAdapter</code>，实现构造方法、onCreateViewHolder、onBindViewHolder、getItemViewType、getItemCount五个主要方法，adapter类以<code>List&lt;BaseDataImpl&gt;</code>界面数据集合，根据BaseDataImpl的不同type来创建和绑定不同的viewHolder;</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">BaseViewHolder</span>&gt; </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;BaseDataImpl&gt; mData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyAdapter</span><span class=\"params\">(List&lt;BaseDataImpl&gt; mData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mData = mData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(List&lt;BaseDataImpl&gt; data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mData = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BaseViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (IBaseData.TYPE_FIRST == viewType) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LeftTextViewHolder(parent, R.layout.item_left_text);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (IBaseData.TYPE_SECOND == viewType) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RightTextViewHolder(parent, R.layout.item_right_text);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(BaseViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</span><br><span class=\"line\">        holder.bindViewHolder(mData.get(position), position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemViewType</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mData.get(position) == <span class=\"keyword\">null</span> ? IBaseData.TYPE_NULL: mData.get(position).getType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mData == <span class=\"keyword\">null</span>? <span class=\"number\">0</span>: mData.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item-left-text如下，RightData与LeftData数据结构一样，item-right-text布局靠右对齐，item-left-text靠左对齐；\"><a href=\"#其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item-left-text如下，RightData与LeftData数据结构一样，item-right-text布局靠右对齐，item-left-text靠左对齐；\" class=\"headerlink\" title=\"其中LeftTextViewHolder是BaseViewHolder的实现类，对应的数据结构LeftData与界面布局item_left_text如下，RightData与LeftData数据结构一样，item_right_text布局靠右对齐，item_left_text靠左对齐；\"></a>其中<code>LeftTextViewHolder</code>是<code>BaseViewHolder</code>的实现类，对应的数据结构<code>LeftData</code>与界面布局<code>item_left_text</code>如下，<code>RightData</code>与<code>LeftData</code>数据结构一样，<code>item_right_text</code>布局靠右对齐，<code>item_left_text</code>靠左对齐；</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeftData</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String subTitle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LeftData</span><span class=\"params\">(String title, String subTitle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subTitle = subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSubTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSubTitle</span><span class=\"params\">(String subTitle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subTitle = subTitle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/tv_title&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_alignParentLeft=&quot;true&quot;</span><br><span class=\"line\">        android:layout_alignParentTop=&quot;true&quot;</span><br><span class=\"line\">        android:layout_marginLeft=&quot;15dp&quot;</span><br><span class=\"line\">        android:paddingTop=&quot;15dp&quot;</span><br><span class=\"line\">        android:text=&quot;我是标题&quot;</span><br><span class=\"line\">        android:textColor=&quot;#000000&quot;</span><br><span class=\"line\">        android:textSize=&quot;16sp&quot; /&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:id=&quot;@+id/tv_subTitle&quot;</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@id/tv_title&quot;</span><br><span class=\"line\">        android:layout_marginLeft=&quot;15dp&quot;</span><br><span class=\"line\">        android:layout_marginTop=&quot;8dp&quot;</span><br><span class=\"line\">        android:paddingBottom=&quot;15dp&quot;</span><br><span class=\"line\">        android:text=&quot;我是子标题&quot;</span><br><span class=\"line\">        android:textColor=&quot;#99000000&quot;</span><br><span class=\"line\">        android:textSize=&quot;12sp&quot; /&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\"><a href=\"#在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\" class=\"headerlink\" title=\"在界面类RecyclerViewActivity中引中新建的adapter类，并传入不同类型的数据，如LeftData封装进BaseDataImpl统一由MyAdapter处理\"></a>在界面类<code>RecyclerViewActivity</code>中引中新建的adapter类，并传入不同类型的数据，如<code>LeftData</code>封装进<code>BaseDataImpl</code>统一由<code>MyAdapter</code>处理</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecyclerViewActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_recyclerview);</span><br><span class=\"line\"></span><br><span class=\"line\">        RecyclerView rvContent = (RecyclerView) findViewById(R.id.rv_content);</span><br><span class=\"line\">        rvContent.setLayoutManager(<span class=\"keyword\">new</span> LinearLayoutManager(<span class=\"keyword\">this</span>, LinearLayoutManager.VERTICAL, <span class=\"keyword\">false</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        LeftData leftData = <span class=\"keyword\">new</span> LeftData(<span class=\"string\">&quot;我是主标题我是主标题&quot;</span>,<span class=\"string\">&quot;我是小标题我是小标题我是小标题&quot;</span>);</span><br><span class=\"line\">        BaseDataImpl leftImpl = <span class=\"keyword\">new</span> BaseDataImpl(leftData, IBaseData.TYPE_FIRST);</span><br><span class=\"line\"></span><br><span class=\"line\">        RightData rightData = <span class=\"keyword\">new</span> RightData(<span class=\"string\">&quot;我是主标题我是主标题&quot;</span>,<span class=\"string\">&quot;我是小标题我是小标题我是小标题&quot;</span>);</span><br><span class=\"line\">        BaseDataImpl rightImpl = <span class=\"keyword\">new</span> BaseDataImpl(rightData, IBaseData.TYPE_SECOND);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;BaseDataImpl&gt; dataList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        dataList.add(leftImpl);</span><br><span class=\"line\">        dataList.add(rightImpl);</span><br><span class=\"line\"></span><br><span class=\"line\">        MyAdapter myAdapter = <span class=\"keyword\">new</span> MyAdapter(dataList);</span><br><span class=\"line\">        rvContent.setAdapter(myAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\"><a href=\"#界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\" class=\"headerlink\" title=\"界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。\"></a>界面显示效果如下，这样就实现了在同一个recyclerView中显示不同样式的布局。</h4><p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/2021-01-26-121132.png\" alt=\"2021-01-26-121132\"></p>\n","categories":["工作小结"],"tags":["android","recyclerview"]},{"title":"06-图3 六度空间","url":"/2021/07/24/06-%E5%9B%BE3%20%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/","content":"<p>​    “六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图所示。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/2021/season1/sixdegree.png\"></p>\n<p>​    “六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>\n<p>​    假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>\n<h5 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式:\"></a>输入格式:</h5><p>​    输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p>\n<h5 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h5><p>​    对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>\n<h5 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">6</span> <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">9</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例:\"></a>输出样例:</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>: <span class=\"number\">70.00</span>%</span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"number\">80.00</span>%</span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"number\">90.00</span>%</span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"number\">100.00</span>%</span><br><span class=\"line\"><span class=\"number\">5</span>: <span class=\"number\">100.00</span>%</span><br><span class=\"line\"><span class=\"number\">6</span>: <span class=\"number\">100.00</span>%</span><br><span class=\"line\"><span class=\"number\">7</span>: <span class=\"number\">100.00</span>%</span><br><span class=\"line\"><span class=\"number\">8</span>: <span class=\"number\">90.00</span>%</span><br><span class=\"line\"><span class=\"number\">9</span>: <span class=\"number\">80.00</span>%</span><br><span class=\"line\"><span class=\"number\">10</span>: <span class=\"number\">70.00</span>%</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><ol>\n<li>输入图的顶点数Nv和边数Ne</li>\n<li>根据顶点数Nv创建零图Graph</li>\n<li>循环输入Ne条边，并插入到图Graph中</li>\n<li>遍历所有的顶点，查找层级6级以内的顶点数与总顶点数的百分比</li>\n</ol>\n<h5 id=\"关键算法BSF\"><a href=\"#关键算法BSF\" class=\"headerlink\" title=\"关键算法BSF\"></a>关键算法BSF</h5><ol>\n<li>定义变量层级level,6级内的顶点数count，</li>\n<li>定义变量上一层级最后一个顶点last，当前遍历最后一个顶点tail，</li>\n<li>创建队列Q，并将当前结点S加入队列</li>\n<li>遍历队列至空</li>\n<li>将头元素移除出队列Q得到当前顶点V</li>\n<li>遍历当前顶点V所有相交的点</li>\n<li>如果V的邻接点W未被访问过，则加入队列Q，count加1，tail指向当前顶点，数组标记该顶点为true</li>\n<li>判断当前遍历的顶点是否为上一层遍历的最末顶点，如果是，层级level加1，last重新指向当前层的最后一个元素</li>\n<li>判断是否满6层，是则跳出所有遍历，返回访问过的顶点数count</li>\n</ol>\n<h5 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Vertex;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">PtrToQNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.数组Data存放元素，循环存放实现循环队列</span></span><br><span class=\"line\">    Vertex *Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.设置队头front与rear队尾两个指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> front, rear;</span><br><span class=\"line\">    <span class=\"comment\">// 3.队列的最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToQNode Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span> </span>&#123;</span><br><span class=\"line\">    Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请队列Queue的空间</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = (Queue) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2.动态申请队列中数组Data的空间,</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;Data = (Vertex *) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Vertex) * MaxSize);</span><br><span class=\"line\">    <span class=\"comment\">// 3.最大长度为MaxSize</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">    <span class=\"comment\">// 4.初始化队头front与队尾rear指针为0</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;front = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 队头front与队尾rear相等，则为空队列</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;rear == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.队尾rear+1模以容量等于队头front，则队列已满</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入列 - 队尾rear</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AddQ</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, Vertex item)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 判断队列是否已满</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsFull(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is full!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.找到队列尾rear指针，在原指针加1后模以容量，以防在最队尾，重回队头</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;rear = (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">    <span class=\"comment\">// 3.在队列的数组Data的第rear个位置插入元素item</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;rear] = item;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出列 - 队头front</span></span><br><span class=\"line\"><span class=\"function\">Vertex <span class=\"title\">DeleteQ</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断队列是否为空</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.找到队头指针front,在原有指针上加1模以容量，如果在最末位，则重返数组第1位</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;front = (<span class=\"built_in\">queue</span>-&gt;front + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">    <span class=\"comment\">// 3.返回队头front指针的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;front];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxVertexNum 1001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//typedef int Vertex;// 用整形表示顶点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> WeightType; <span class=\"comment\">// 权重</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> DataType;<span class=\"comment\">// 顶点数据，字符型</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> Visited[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> *<span class=\"title\">PtrToENode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToENode Edge;</span><br><span class=\"line\"><span class=\"comment\">//边的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> &#123;</span></span><br><span class=\"line\">    WeightType Weight;</span><br><span class=\"line\">    Vertex V1, V2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// 邻接点的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> &#123;</span></span><br><span class=\"line\">    Vertex AdjV;<span class=\"comment\">//邻结点下标</span></span><br><span class=\"line\">    WeightType Weight;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表头结点的定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span> &#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge; <span class=\"comment\">// 边表头指针</span></span><br><span class=\"line\">    DataType Data; <span class=\"comment\">// 顶点的数据</span></span><br><span class=\"line\">&#125; AdjList[MaxVertexNum]; <span class=\"comment\">// Vnode类型的数组，大小为MaxVertexNum个</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv, Ne;</span><br><span class=\"line\">    AdjList G;<span class=\"comment\">// 邻接表，所有表头结点的数组 - 链表</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LGraph <span class=\"title\">CreateGraph</span><span class=\"params\">(<span class=\"keyword\">int</span> VertexNum)</span> </span>&#123;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    LGraph Graph;</span><br><span class=\"line\">    Graph = (LGraph) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct GNode));</span><br><span class=\"line\">    Graph-&gt;Nv = VertexNum;</span><br><span class=\"line\">    Graph-&gt;Ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 从顶点1开始初始化，包含最末位的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">1</span>; V &lt;= Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化各个结点的表头指针</span></span><br><span class=\"line\">        Graph-&gt;G[V].FirstEdge = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化结点未被访问</span></span><br><span class=\"line\">        Visited[V] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertEdge</span><span class=\"params\">(LGraph Graph, Edge E)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 插入边&lt;V1,V2&gt;</span></span><br><span class=\"line\">    PtrToAdjVNode NewNode;</span><br><span class=\"line\">    NewNode = (PtrToAdjVNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AdjVNode));</span><br><span class=\"line\">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class=\"line\">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 将新的邻边结点V2插入V1的表头</span></span><br><span class=\"line\">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    NewNode = (PtrToAdjVNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AdjVNode));</span><br><span class=\"line\">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class=\"line\">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 将V1插入v2的表头</span></span><br><span class=\"line\">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广度优先搜索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BFS</span><span class=\"params\">(LGraph Graph, Vertex S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.定义变量层级level,6级内的顶点数count，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count, level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    <span class=\"comment\">// 2.定义变量上一层级最后一个顶点last，当前遍历最后一个顶点tail，</span></span><br><span class=\"line\">    Vertex V, last = S, tail;</span><br><span class=\"line\">    PtrToAdjVNode W;</span><br><span class=\"line\">    <span class=\"comment\">// 3.创建队列Q，并将当前结点S加入队列</span></span><br><span class=\"line\">    Q = CreateQueue(MaxVertexNum);</span><br><span class=\"line\">    Visited[S] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    AddQ(Q, S);</span><br><span class=\"line\">    <span class=\"comment\">// 4.遍历队列至空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!IsEmpty(Q)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5.将头元素移除出队列Q得到当前顶点V</span></span><br><span class=\"line\">        V = DeleteQ(Q);</span><br><span class=\"line\">        <span class=\"comment\">// 6.遍历当前顶点V所有相交的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7.如果V的邻接点W未被访问过，则加入队列Q，count加1，tail指向当前顶点，</span></span><br><span class=\"line\">            <span class=\"comment\">// 数组标记该顶点为true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Visited[W-&gt;AdjV]) &#123;</span><br><span class=\"line\">                Visited[W-&gt;AdjV] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                AddQ(Q, W-&gt;AdjV);</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                tail = W-&gt;AdjV;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 8.判断当前遍历的顶点是否为上一层遍历的最末顶点，如果是，层级level加1，last重新指向当前层的最后一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V == last) &#123;</span><br><span class=\"line\">            level++;</span><br><span class=\"line\">            last = tail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 9.判断是否满6层，是则跳出所有遍历，返回访问过的顶点数count</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">6</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, Nv, Ne, V1, V2, count;</span><br><span class=\"line\">    Edge E;</span><br><span class=\"line\">    Vertex i;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 输入图的顶点数Nv和边数Ne</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;Nv, &amp;Ne);</span><br><span class=\"line\">    <span class=\"comment\">// 2.根据顶点数Nv创建零图Graph</span></span><br><span class=\"line\">    LGraph Graph = CreateGraph(Nv);</span><br><span class=\"line\">    <span class=\"comment\">// 3.循环输入Ne条边，并插入到图Graph中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Ne; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;V1, &amp;V2);</span><br><span class=\"line\">        E = (Edge) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ENode));</span><br><span class=\"line\">        E-&gt;V1 = V1;</span><br><span class=\"line\">        E-&gt;V2 = V2;</span><br><span class=\"line\">        E-&gt;Weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">        InsertEdge(Graph, E);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.遍历所有的顶点，查找层级6级以内的顶点数与总顶点数的百分比</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= Nv; i++) &#123;</span><br><span class=\"line\">        count = BFS(Graph, i);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: %.2f%\\n&quot;</span>, i, (<span class=\"keyword\">float</span>) count * <span class=\"number\">100</span> / (<span class=\"keyword\">float</span>) Nv);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt;= Nv; j++) &#123;</span><br><span class=\"line\">            Visited[j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h5><ol>\n<li>图结构的选择，邻接矩阵还是邻接表？这里索性用邻接表；</li>\n<li>遍历某个顶点时，如何判断是否遍历完当前层，这里加了两个字段last和tail，用以标记上一层最后一个顶点和当前层遍历末位顶点；</li>\n<li>初始化图顶点，或是遍历所有顶点，需要注意上下限值，顶点从1开始，至第Nv个。</li>\n</ol>\n","categories":["PTA"],"tags":["图","图习题"]},{"title":"Android自定义控件小结","url":"/2021/01/14/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%B0%8F%E7%BB%93/","content":"<h3 id=\"绘制文本drawText\"><a href=\"#绘制文本drawText\" class=\"headerlink\" title=\"绘制文本drawText\"></a>绘制文本<code>drawText</code></h3><ul>\n<li><p>计算文本的宽度、高度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> textWidth = paint.measureText(text);</span><br><span class=\"line\">Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class=\"line\"><span class=\"keyword\">float</span> textHeight = fontMetrics.top - fontMetrics.bottom;</span><br></pre></td></tr></table></figure></li>\n<li><p>绘制文本，文本绘制起始点在文本矩形的左下角，注意起始点(floatX, floatY)</p>\n<a id=\"more\"></a>\n\n<p><code>canvas.drawText(text, floatX, floatY, paint);</code> </p>\n</li>\n<li><p>利用path绘制倾斜文本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Path path = <span class=\"keyword\">new</span> Path();</span><br><span class=\"line\">path.moveTo(floatX, floatY);<span class=\"comment\">//移到起始点</span></span><br><span class=\"line\">path.lineTo(endX, endY);<span class=\"comment\">// 描路径</span></span><br><span class=\"line\">canvas.drawTextOnPath(text, path, <span class=\"number\">0</span>, <span class=\"number\">0</span>, paint);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"绘制圆角矩形\"><a href=\"#绘制圆角矩形\" class=\"headerlink\" title=\"绘制圆角矩形\"></a>绘制圆角矩形</h3><ul>\n<li><p>直接绘制<code>drawRoundRect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, top, right, bottom);</span><br><span class=\"line\">paint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">canvas.drawRoundRect(rect, floatRX, floatRY, paint);</span><br></pre></td></tr></table></figure></li>\n<li><p>通过裁剪路径<code>clipPath</code>得到，但画布可绘制范围只剩该矩形区域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> r = <span class=\"number\">3</span>; </span><br><span class=\"line\"><span class=\"keyword\">float</span>[] radiusArray = &#123;r,r, r,r, r,r, r,r&#125;;<span class=\"comment\">//对应左、上、右、下四个角的圆角半径</span></span><br><span class=\"line\">Path path = <span class=\"keyword\">new</span> Path();</span><br><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, right, top, bottom);</span><br><span class=\"line\">path.addRoundRect(rect, radiusArray, Path.Direction.CW);</span><br><span class=\"line\">canvas.clipPath(path);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"绘制圆弧drawArc\"><a href=\"#绘制圆弧drawArc\" class=\"headerlink\" title=\"绘制圆弧drawArc\"></a>绘制圆弧<code>drawArc</code></h3><ul>\n<li><p>默认按顺时针方向绘制，设置圆弧所在区域矩形、起始的角度、扫过的角度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">RectF rect = <span class=\"keyword\">new</span> RectF(left, top, right, bottom);</span><br><span class=\"line\">paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">paint.setStrokeCap(Paint.Cap.ROUND);<span class=\"comment\">// 设置描边线为圆角类型</span></span><br><span class=\"line\">canvas.drawArc(rect, startAngle, sweepAngle, <span class=\"keyword\">false</span>, paint);</span><br></pre></td></tr></table></figure></li>\n<li><p>设置圆弧渐变色</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位置数组与色值数组对应</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] GRADIENT_COLORS = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;Color.parseColor(<span class=\"string\">&quot;#F257B0&quot;</span>), Color.parseColor(<span class=\"string\">&quot;#688FFD&quot;</span>)&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 取值范围0-1，0和1为3点钟位置，0.25为6点钟位置，0.5为9点钟位置，0.75为12点位置</span></span><br><span class=\"line\"><span class=\"keyword\">float</span>[] GRADIENT_POSITION = <span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[]&#123;<span class=\"number\">0.45f</span>, <span class=\"number\">1.0f</span>&#125;;</span><br><span class=\"line\">SweepGradient gradient = <span class=\"keyword\">new</span> SweepGradient(cx, cy, GRADIENT_COLORS, GRADIENT_POSITION);</span><br><span class=\"line\">paint.setShader(gradient);</span><br><span class=\"line\">canvas.drawArc(rect, startAngle, sweepAngle, <span class=\"keyword\">false</span>, paint);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ul>\n<li><p>androd屏幕坐标参考系，水平右方向为x轴正方向，水平左方向为x轴负方向，竖直下方向为y轴正方向，竖直上方向为y轴负方向；</p>\n</li>\n<li><p>画布<code>canvas</code>基本操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">canvas.translate(dx, dy); <span class=\"comment\">// 移动画布中心</span></span><br><span class=\"line\">canvas.rotate(degree); <span class=\"comment\">// 画布旋转角度degree</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<ul>\n<li><p>绘制时使用屏幕的实际尺寸，不能直接使用<code>3px</code>;</p>\n<p><code>int width = context.getResources().getDimensionPixelSize(R.dimen.dp_3px);</code></p>\n</li>\n<li><p>Math类的常用运算</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.toRadians(<span class=\"number\">180</span>);<span class=\"comment\">//角度转弧度</span></span><br><span class=\"line\">Math.toDegrees(pi);<span class=\"comment\">//弧度转角度</span></span><br><span class=\"line\">Math.sin(radians);<span class=\"comment\">//计算三角函数sin值，传入弧度</span></span><br><span class=\"line\">Math.ceil(<span class=\"number\">12.7</span>);<span class=\"comment\">//得13 取天花板值</span></span><br><span class=\"line\">Math.floor(<span class=\"number\">12.7</span>);<span class=\"comment\">//得12 取地板值</span></span><br><span class=\"line\">Math.sqrt(<span class=\"number\">4</span>);<span class=\"comment\">// 求开方</span></span><br><span class=\"line\">Math.pow(x,y);<span class=\"comment\">//求x的y次方</span></span><br><span class=\"line\">Math.round(x);<span class=\"comment\">//求整，四舍五入</span></span><br><span class=\"line\">Math.min(x,y); <span class=\"comment\">//最小值</span></span><br><span class=\"line\">Math.max(x,y); <span class=\"comment\">//最大值\t</span></span><br><span class=\"line\">Math.abs(x);<span class=\"comment\">//绝对值</span></span><br><span class=\"line\">Math.random();<span class=\"comment\">// 返回0-1随机数</span></span><br></pre></td></tr></table></figure></li>\n<li><p>浮点数保持精度计算<code>BigDecimal</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal bigDecimal = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;3.14159&quot;</span>);</span><br><span class=\"line\">bigDecimal.setScale(<span class=\"number\">2</span>, BigDecimal.ROUND_DOWN);<span class=\"comment\">// 取小数点后2位</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>动画动态取值<code>ValueAnimator</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(startValue, endValue);</span><br><span class=\"line\">animator.setDuration(<span class=\"number\">3000</span>);<span class=\"comment\">// 设置动画持续时长</span></span><br><span class=\"line\">animator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 在duration时长内，返回startValue-endValue区间的值,根据不同的值重绘界面，形成动态</span></span><br><span class=\"line\">  \t\t<span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>) valueAnimator.getAnimatedValue();</span><br><span class=\"line\">    \tLog.d(TAG, <span class=\"string\">&quot;animator value:&quot;</span> + value);</span><br><span class=\"line\">                    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n","categories":["工作小结"],"tags":["android","自定义控件"]},{"title":"通过CentOS的Docker部署calibre-web搭建私人电子图书馆","url":"/2021/01/13/docker-web%E6%90%AD%E5%BB%BA/","content":"<h3 id=\"前期准备工作\"><a href=\"#前期准备工作\" class=\"headerlink\" title=\"前期准备工作\"></a>前期准备工作</h3><ul>\n<li><p>本地电脑安装Calibre, windows|Mac|Linux各种版本都有，建立本地的书库目录books用于存放电子书及metadata数据库，我这里用的是windows；</p>\n</li>\n<li><p>在windows是安装好与服务器连接的软件Xshell和用于传输文件的Sftp，或是其它同样功能的软件也可以</p>\n</li>\n<li><p>准备好服务器，我这里是选用的centos7，有NAS的也一样可以下载docker进行部署</p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"搭建calibre-web应用\"><a href=\"#搭建calibre-web应用\" class=\"headerlink\" title=\"搭建calibre-web应用\"></a>搭建calibre-web应用</h3><ul>\n<li><p>首先通过<code>docker -v</code> 检查是否安装了docker, 如果未安装通过以下命令安装： <code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code> 是否需要使用Aliyun镜像看个人情况。</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/pull_error.png\" alt=\"docker_version\" style=\"zoom:100%;\">  \n\n\n\n</li>\n</ul>\n<ul>\n<li><p>使用docker命令从github拉取calibre-web应用，github上下载量较高有以下3个：linuxserver/calibre-web，technosoft2000/calibre-web，janeczku/calibre-web, 我用的是第1个，有不少同学说linuxserver/calibre-web不能进行格式转换，但通过正常配置是可以正常转换格式的；<code>docker pull linuxserver/calibre-web</code> 拉取应用，</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/install_calibre.png\" alt=\"pull_error\" style=\"zoom:100%;\">  \n\n\n\n</li>\n</ul>\n<p>  如果报错<code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code> 说明docker应用进程没有正常启动 ，需要先手动启动<code>systemctl restart docker.service</code>，再拉取应用。</p>\n<ul>\n<li><p>在docker中创建calibre-web应用：</p>\n<p><code>docker create \\    --name=calibre-web \\    -e PUID=1000 \\    -e PGID=1000 \\    -e TZ=Asia/Shanghai \\ -p 8083:8083 \\    -e DOCKER_MODS=linuxserver/calibre-web:calibre \\ -v /data/calibre/config:/config \\    -v /data/calibre/books:/books \\ --restart unless-stopped \\    linuxserver/calibre-web</code></p>\n<p>关键参数说明：<code>--name=calibre-web</code>应用名称， <code>-p 8083:8083</code> 端口映射，配置成功后通过该 端口访问，记得防火墙中要放开该端口，否则无法访问 ，<code>-e DOCKER_MODS=linuxserver/calibre-web:calibre</code>是否需要支持格式功能，仅x86_64的cpu支持（但还需要在calibre-web中进行配置），<code>-v /data/calibre/config:/config</code>服务器本地与calibre应用配置文件夹映射关系，用于存放用户数据等，<code>-v /data/calibre/books:/books</code>服务器本地与calibre书籍目录映射关系。</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/mkdir.png\" alt=\"install_calibre\" style=\"zoom:100%;\">\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>在centos中使用mkdir命令创建目录/data/calibre/books和/data/calibre/config，并授予文件夹读写权限</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/docker_version.png\" alt=\"mkdir\" style=\"zoom:100%;\">\n</li>\n<li><p>在windows下Calibre本地书库中books，使用xftp将本地windows书库中的所有电子书导入到centos服务器<code>/data/calibre/books</code> 目录下，注意：books目录下的除了所有书籍文件夹上传外，metadata.db数据库也一并上传到centos7中的/data/calibre/books目录下，不然会报“数据库路径无效，请输入正确的路径”</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/base_config.png\" alt=\"tanslate_books\" style=\"zoom:100%;\">\n</li>\n<li><p>在服务中开启calibre-web应用<code>docker start calibre-web</code>, 通过浏览器打开<code>http://host:8083</code>进入calibre-web，在calibre书库配置中填写<code>/books</code>即映射到centos服务器中的<code>/data/calibre/books</code>目录下；如果提示“数据库路径无效，请输入正确的路径”，在本地windows中Calibre软件重新创建一个书库文件夹，并将其文件夹下的metadata.db文件单独上传上述centos服务器路径；并对文件夹授予读写权限<code> chmod -R 777 /data/calibre/</code></p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/login.png\" alt=\"base_config\" style=\"zoom:100%;\">\n</li>\n<li><p>使用管理员账号admin/admin123登录calibre-web，并在设置中心修改为语言为中文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/translate_books.png\" alt=\"login\" style=\"zoom:100%;\">\n</li>\n<li><p>登录成功，界面默认为英文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/lang_config.png\" alt=\"login_success\" style=\"zoom:75%;\">\n</li>\n<li><p>点击用户名admin，在Language下修改语言为中文</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert_router.png\" alt=\"lang_config\" style=\"zoom:100%;\">\n</li>\n<li><p>修改成功的中文界面</p>\n<img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/add_permision.png\" alt=\"lang_cn\" style=\"zoom:100%;\">\n\n\n\n</li>\n</ul>\n<h3 id=\"Calibre-web功能进阶：格式转换-amp-邮件转发至Kindle\"><a href=\"#Calibre-web功能进阶：格式转换-amp-邮件转发至Kindle\" class=\"headerlink\" title=\"Calibre-web功能进阶：格式转换 &amp;邮件转发至Kindle\"></a>Calibre-web功能进阶：格式转换 &amp;邮件转发至Kindle</h3><ul>\n<li><p>登录管理员账号找到 管理权限 - 配置 - 编辑基本配置 - 扩展程序配置，在“Calibre电子书转换路径”栏中填写 <code>/usr/bin/ebook-convert</code> 在Unrar程序路径填<code>/usr/bin/unrar</code>，</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/lang_cn.png\" alt=\"convert_router\"></p>\n<p>注意在容器创建时添加了参数<code>-e DOCKER_MODS=linuxserver/calibre-web:calibre</code> 才能支持格式转换，另外，还需要在centos下新建目录并在路径下添加权限、添加权限、添加权限，重要的事说3遍，<code>chmod -R 777 /usr/bin/ebook-convert</code> </p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert-book.png\" alt=\"add_permision\"></p>\n</li>\n<li><p>在书籍编辑界面对书籍进行格式转换，在任务列表中可以查看转换进度，如果没有给目录<code>/usr/bin/ebook-convert</code>添加权限，在转换进度的最后时刻会提示失败。</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/convert-success.png\" alt=\"convert-book\"></p>\n<p>转换成功：</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/config_email.png\" alt=\"convert-success\"></p>\n</li>\n<li><p>设置将电子书通过邮件发送到kindle邮箱，以163为例，首行登录到邮箱首页，找到设置 - POP3/SMTP/IMAP</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/smtp_code.png\" alt=\"login_email\"></p>\n<p>然后打开IMAP/SMTP服务，接着新增授权码，记住该码</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/login_email.png\" alt=\"smtp_code\"></p>\n</li>\n<li><p>登录管理员账号找到 管理权限 - SMTP邮件服务器配置 - 编辑邮件服务器配置，按下图填写信息，其中SMTP密码就是上一步中从163邮箱中获取到的授权密码，保存，在查看书籍信息时右上角就有转发到邮件的选项了，但是为了让你的kindle可以正常接收到电子书邮件，还需要登录你的亚马逊账户，在设置中添加可依赖的发件邮箱，即上面的163邮箱。</p>\n<p><img src=\"http://penney.oss-cn-shenzhen.aliyuncs.com/typora/config_email.png\" alt=\"config_email\"></p>\n</li>\n</ul>\n","categories":["瞎折腾"],"tags":["centos","docker","calibre-web","电子书"]},{"title":"图结构_邻接表","url":"/2021/07/25/%E5%9B%BE%E7%BB%93%E6%9E%84-%E9%82%BB%E6%8E%A5%E8%A1%A8/","content":"<h4 id=\"结构-边-ENode-PtrToENode-Edge\"><a href=\"#结构-边-ENode-PtrToENode-Edge\" class=\"headerlink\" title=\"结构 - 边 ENode - PtrToENode - Edge\"></a>结构 - 边 ENode - PtrToENode - Edge</h4><ol>\n<li>1.无向边(V1,V2),V1 V2为顶点</li>\n<li>权重Weight</li>\n</ol>\n<h4 id=\"结构-邻接点-AdjVNode-PtrToAdjVNode\"><a href=\"#结构-邻接点-AdjVNode-PtrToAdjVNode\" class=\"headerlink\" title=\"结构 - 邻接点 AdjVNode - PtrToAdjVNode\"></a>结构 - 邻接点 AdjVNode - PtrToAdjVNode</h4><ol>\n<li>邻结点下标AdjV</li>\n<li>邻结点权重Weight</li>\n<li>下一个邻接点Next</li>\n</ol>\n<a id=\"more\"></a>\n\n<h4 id=\"结构-头结点-Vnode-AdjList\"><a href=\"#结构-头结点-Vnode-AdjList\" class=\"headerlink\" title=\"结构 - 头结点 Vnode - AdjList\"></a>结构 - 头结点 Vnode - AdjList</h4><ol>\n<li>边表头指针,第一个邻接点FirstEdge</li>\n<li>顶点的数据Data</li>\n<li>Vnode类型的顶点数组AdjList</li>\n</ol>\n<h4 id=\"结构-图结点-GNode-PtrToGNode-LGraph\"><a href=\"#结构-图结点-GNode-PtrToGNode-LGraph\" class=\"headerlink\" title=\"结构 - 图结点 GNode - PtrToGNode - LGraph\"></a>结构 - 图结点 GNode - PtrToGNode - LGraph</h4><ol>\n<li>图的顶点数Nv,边数Ne</li>\n<li>邻接表，所有表头结点AdjList的数组G</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Vertex;<span class=\"comment\">// 用整形表示顶点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> WeightType; <span class=\"comment\">// 权重</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> DataType;<span class=\"comment\">// 顶点数据，字符型</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> Visited[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> *<span class=\"title\">PtrToENode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToENode Edge;</span><br><span class=\"line\"><span class=\"comment\">//边的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.无向边(V1,V2),V1 V2为顶点</span></span><br><span class=\"line\">    Vertex V1, V2;</span><br><span class=\"line\">    <span class=\"comment\">//2.权重Weight</span></span><br><span class=\"line\">    WeightType Weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// 邻接点的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.邻结点下标</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    <span class=\"comment\">//2.邻结点权重</span></span><br><span class=\"line\">    WeightType Weight;</span><br><span class=\"line\">    <span class=\"comment\">//3.下一个邻接点</span></span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表头结点的定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.边表头指针,第一个邻接点</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">    <span class=\"comment\">// 2.顶点的数据</span></span><br><span class=\"line\">    DataType Data;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum]; <span class=\"comment\">// 3.Vnode类型的顶点数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// 图结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.图的顶点数Nv,边数Ne</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv, Ne;</span><br><span class=\"line\">    <span class=\"comment\">// 2.邻接表，所有表头结点的数组 - 链表</span></span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建零图</span></span><br><span class=\"line\"><span class=\"function\">LGraph <span class=\"title\">CreateGraph</span><span class=\"params\">(<span class=\"keyword\">int</span> VertexNum)</span> </span>&#123;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    LGraph Graph;</span><br><span class=\"line\">    Graph = (LGraph) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct GNode));</span><br><span class=\"line\">    Graph-&gt;Nv = VertexNum;</span><br><span class=\"line\">    Graph-&gt;Ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化各个结点的表头指针</span></span><br><span class=\"line\">        Graph-&gt;G[V].FirstEdge = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化结点未被访问</span></span><br><span class=\"line\">        Visited[V] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入边E&lt;V1,V2&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertEdge</span><span class=\"params\">(LGraph Graph, Edge E)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请邻接点NewNode</span></span><br><span class=\"line\">    PtrToAdjVNode NewNode;</span><br><span class=\"line\">    NewNode = (PtrToAdjVNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AdjVNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2.将边E的终点V2填入NewNode中AdjV，及权重Weight</span></span><br><span class=\"line\">    NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class=\"line\">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 3.将新的邻边结点NewNode插入起始点V1的表头</span></span><br><span class=\"line\">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4.如果E是无向边，同样需要插入V2为始点V1为终点的链表中</span></span><br><span class=\"line\">    NewNode = (PtrToAdjVNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AdjVNode));</span><br><span class=\"line\">    NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class=\"line\">    NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 将V1插入v2的表头</span></span><br><span class=\"line\">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造邻接表，包含顶点与边</span></span><br><span class=\"line\"><span class=\"function\">LGraph <span class=\"title\">BuildGraph</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LGraph Graph;</span><br><span class=\"line\">    Edge E;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv, i;</span><br><span class=\"line\">    <span class=\"comment\">//1.读取顶点数Nv</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class=\"line\">    Graph = CreateGraph(Nv);</span><br><span class=\"line\">    <span class=\"comment\">//2.读取边数Ne</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Graph-&gt;Ne != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        E = (Edge) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ENode));</span><br><span class=\"line\">        <span class=\"comment\">// 3.循环读入边的数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Ne; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class=\"line\">            InsertEdge(Graph, E);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.输入顶点数据Data</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;(Graph-&gt;G[V].Data));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(Vertex V)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;正在访问顶点%d\\n&quot;</span>, V);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接表深度优先搜索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(LGraph Graph, Vertex V, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">    PtrToAdjVNode W;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先访问邻结点V</span></span><br><span class=\"line\">    Visit(V);</span><br><span class=\"line\">    Visited[V] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历搜索下一个邻接点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//3.如果W未访问过，递归访问DFS</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Visited[W-&gt;Next-&gt;AdjV])</span><br><span class=\"line\">            DFS(Graph, W-&gt;Next-&gt;AdjV, Visit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//邻接表的广度优先搜索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(LGraph Graph, Vertex S, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    PtrToAdjVNode W;</span><br><span class=\"line\">    <span class=\"comment\">//1.创建队列Q，并将结点S加入队列</span></span><br><span class=\"line\">    Q = CreateQueue(MaxSize);</span><br><span class=\"line\">    Visit(S);</span><br><span class=\"line\">    Visited[S] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    AddQ(Q, S);</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历队列直到为空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!IsEmpty(Q)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.从队头删除元素V</span></span><br><span class=\"line\">        V = DeleteQ(Q);</span><br><span class=\"line\">        <span class=\"comment\">// 4.遍历与V相邻的所有顶点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = Graph-&gt;G[S].FirstEdge; W; W = W-&gt;Next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5.如果未访问过,则访问该顶点，同时加入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Visited[W-&gt;Next]) &#123;</span><br><span class=\"line\">                Visit(W);</span><br><span class=\"line\">                Visited[W] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                AddQ(Q, W);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无权图 - 无权图的单源最短路算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UnWeighted</span><span class=\"params\">(LGraph Graph, <span class=\"keyword\">int</span> dist[], <span class=\"keyword\">int</span> path[], Vertex S)</span> </span>&#123;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    PtrToAdjVNode W;</span><br><span class=\"line\">    <span class=\"comment\">// 创建空队列, MaxSize为外部定义的常数</span></span><br><span class=\"line\">    Q = CreateQueue(Graph-&gt;Nv);</span><br><span class=\"line\">    <span class=\"comment\">//初始化源点</span></span><br><span class=\"line\">    dist[S] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    AddQ(Q, S);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!IsEmpty(Q)) &#123;</span><br><span class=\"line\">        V = DeleteQ(Q);</span><br><span class=\"line\">        <span class=\"comment\">//对V的每个邻接点W-&gt;AdjV</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若W-&gt;AdjV未被访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[W-&gt;AdjV] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//W-&gt;AdjV到S的距离更新</span></span><br><span class=\"line\">                dist[W-&gt;AdjV] = dist[V] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将V记录在S到W-&gt;AdjV的路径上</span></span><br><span class=\"line\">                path[W-&gt;AdjV] = V;</span><br><span class=\"line\">                AddQ(Q, W-&gt;AdjV);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["图","邻接表"]},{"title":"图结构_邻接矩阵","url":"/2021/07/25/%E5%9B%BE%E7%BB%93%E6%9E%84_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/","content":"<h4 id=\"结构-图结点-GNode-PtrToGNode-MGraph\"><a href=\"#结构-图结点-GNode-PtrToGNode-MGraph\" class=\"headerlink\" title=\"结构 - 图结点 GNode - PtrToGNode - MGraph\"></a>结构 - 图结点 GNode - PtrToGNode - MGraph</h4><ol>\n<li>顶点数Nv</li>\n<li>边数Ne</li>\n<li>邻接矩阵二维数组G</li>\n<li>顶点数据Data</li>\n</ol>\n<a id=\"more\"></a>\n\n<h4 id=\"结构-边结构\"><a href=\"#结构-边结构\" class=\"headerlink\" title=\"结构 - 边结构\"></a>结构 - 边结构</h4><ol>\n<li>无向边(V1,V2),V1 V2为顶点</li>\n<li>权重Weight</li>\n</ol>\n<h4 id=\"创建零图\"><a href=\"#创建零图\" class=\"headerlink\" title=\"创建零图\"></a>创建零图</h4><ol>\n<li>创建一个有VertexNum个顶点0条边的图MGraph</li>\n<li>遍历,初始化二维数组,顶点的权重为无限大或-1</li>\n</ol>\n<h4 id=\"向图中插入边\"><a href=\"#向图中插入边\" class=\"headerlink\" title=\"向图中插入边\"></a>向图中插入边</h4><ol>\n<li>插入边&lt;v1,v2&gt;,二维数组的顶点V1,V2写入权重Weight</li>\n<li>如果是无向图还需要插入反向点，对称矩阵</li>\n</ol>\n<h4 id=\"创建图-含顶点与边\"><a href=\"#创建图-含顶点与边\" class=\"headerlink\" title=\"创建图,含顶点与边\"></a>创建图,含顶点与边</h4><ol>\n<li>读入顶点个数，构造含有Nv个顶点无边的图</li>\n<li>读入边数Ne</li>\n<li>循环读入一条边,并插入Graph中</li>\n<li>如果顶点有数据的话的，读入数据</li>\n</ol>\n<h4 id=\"是否无连接边\"><a href=\"#是否无连接边\" class=\"headerlink\" title=\"是否无连接边\"></a>是否无连接边</h4><ol>\n<li>邻接矩阵是否为INFINITY或-1</li>\n</ol>\n<h4 id=\"BFS广度优先搜索邻接矩阵图\"><a href=\"#BFS广度优先搜索邻接矩阵图\" class=\"headerlink\" title=\"BFS广度优先搜索邻接矩阵图\"></a>BFS广度优先搜索邻接矩阵图</h4><ol>\n<li>创建队列Q,访问结点S并将结点S加入队列Q</li>\n<li>遍历队列至为空</li>\n<li>将元素移出队列得到V</li>\n<li>遍历所有的顶点</li>\n<li>若W是V的邻接点并且未访问过</li>\n<li>访问新的结点W并将新结点W加入队列</li>\n</ol>\n<h4 id=\"DFS邻接矩阵的深度优先搜索\"><a href=\"#DFS邻接矩阵的深度优先搜索\" class=\"headerlink\" title=\"DFS邻接矩阵的深度优先搜索\"></a>DFS邻接矩阵的深度优先搜索</h4><ol>\n<li>先访问结点v，并将标记置为true</li>\n<li>遍历与V相邻的结点</li>\n<li>找到下一个与V点相交的点，同时该点未被访问</li>\n<li>递归与V相邻的第一个未访问的结点W</li>\n</ol>\n<h4 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INFINITY 65535</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxSize 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Vertex;<span class=\"comment\">// 用整形表示顶点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> WeightType; <span class=\"comment\">// 权重</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> DataType;<span class=\"comment\">// 顶点数据，字符型</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> Visited[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode MGraph;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.顶点数Nv</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"comment\">//2.边数Ne</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Ne;</span><br><span class=\"line\">    <span class=\"comment\">//3.邻接矩阵二维数组G</span></span><br><span class=\"line\">    WeightType G[MaxVertexNum][MaxVertexNum];</span><br><span class=\"line\">    <span class=\"comment\">//4.顶点数据Data</span></span><br><span class=\"line\">    DataType Data[MaxVertexNum];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> *<span class=\"title\">PtrToENode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToENode Edge;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ENode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.无向边(V1,V2),V1 V2为顶点</span></span><br><span class=\"line\">    Vertex V1, V2;</span><br><span class=\"line\">    <span class=\"comment\">//2.权重Weight</span></span><br><span class=\"line\">    WeightType Weight;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建零图</span></span><br><span class=\"line\"><span class=\"function\">MGraph <span class=\"title\">CreateGraph</span><span class=\"params\">(<span class=\"keyword\">int</span> VertexNum)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建一个有VertexNum个顶点0条边的图MGraph</span></span><br><span class=\"line\">    Vertex V, W;</span><br><span class=\"line\">    MGraph Graph;</span><br><span class=\"line\">    Graph = (MGraph) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct GNode));</span><br><span class=\"line\">    Graph-&gt;Nv = VertexNum;</span><br><span class=\"line\">    Graph-&gt;Ne = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历,初始化二维数组,顶点的权重为无限大或-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++)</span><br><span class=\"line\">            Graph-&gt;G[V][W] = INFINITY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向图中插入边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertEdge</span><span class=\"params\">(MGraph Graph, Edge E)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.插入边&lt;v1,v2&gt;,二维数组的顶点V1,V2写入权重Weight</span></span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果是无向图还需要插入反向点，对称矩阵</span></span><br><span class=\"line\">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建图,含顶点与边</span></span><br><span class=\"line\"><span class=\"function\">MGraph <span class=\"title\">BuildGraph</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MGraph Graph;</span><br><span class=\"line\">    Edge E;</span><br><span class=\"line\">    Vertex V;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Nv, i;</span><br><span class=\"line\">    <span class=\"comment\">//1.读入顶点个数，构造含有Nv个顶点无边的图</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class=\"line\">    Graph = CreateGraph(Nv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2.读入边数Ne</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Graph-&gt;Ne != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        E = (Edge) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ENode));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Ne; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 3.循环读入一条边,并插入Graph中</span></span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class=\"line\">            InsertEdge(Graph, E);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.如果顶点有数据的话的，读入数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %c &quot;</span>, &amp;(Graph-&gt;Data[V]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否无连接边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEdge</span><span class=\"params\">(MGraph Graph, Vertex V, Vertex W)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Graph-&gt;G[V][W] &lt; INFINITY ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span><span class=\"params\">(Vertex V)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;正在访问顶点%d\\n&quot;</span>, V);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广度优先搜索邻接矩阵图</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(MGraph Graph, Vertex S, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">    Queue Q;</span><br><span class=\"line\">    Vertex V, W;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建队列Q,访问结点S并将结点S加入队列Q</span></span><br><span class=\"line\">    Q = CreateQueue(MaxSize);</span><br><span class=\"line\">    Visit(S);</span><br><span class=\"line\">    Visited[S] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    AddQ(Q, S);</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历队列至为空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!IsEmpty(Q)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//3.将元素移出队列得到V</span></span><br><span class=\"line\">        V = DeleteQ(Q);</span><br><span class=\"line\">        <span class=\"comment\">//4.遍历所有的顶点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = <span class=\"number\">1</span>; W &lt;= Graph-&gt;Nv; W++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//5.若W是V的邻接点并且未访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Visited[W] &amp;&amp; isEdge(Graph, V, W)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 6.访问新的结点W并将新结点W加入队列</span></span><br><span class=\"line\">                Visit(W);</span><br><span class=\"line\">                Visited[W] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                AddQ(Q, W);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 邻接矩阵的深度优先搜索</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph Graph, Vertex V, <span class=\"keyword\">void</span>(*Visit)(Vertex))</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先访问结点v，并将标记置为true</span></span><br><span class=\"line\">    Visit(V);</span><br><span class=\"line\">    Visited[V] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    Vertex W;</span><br><span class=\"line\">    <span class=\"comment\">// 2.遍历与V相邻的结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//3.找到下一个与V点相交的点，同时该点未被访问</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Graph-&gt;G[V][W] &amp;&amp; !Visited[W]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.递归与V相邻的第一个未访问的结点W</span></span><br><span class=\"line\">            DFS(Graph, W, Visit);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求最短距离的顶点</span></span><br><span class=\"line\"><span class=\"function\">Vertex <span class=\"title\">FindMinDist</span><span class=\"params\">(MGraph Graph, <span class=\"keyword\">int</span> dist[], <span class=\"keyword\">int</span> collected[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0.变量MinDist最短距离，MinV为对应的顶点</span></span><br><span class=\"line\">    Vertex MinV, V;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> MinDist = INFINITY;</span><br><span class=\"line\">    <span class=\"comment\">// 1.遍历所有顶点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.若V未被收录，且dist[V]更小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (collected[V] = <span class=\"literal\">false</span> &amp;&amp; dist[V] &lt; MinDist) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//3.更新最小距离,更新对应顶点</span></span><br><span class=\"line\">            MinDist = dist[V];</span><br><span class=\"line\">            MinV = V;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//4.若找到最小dist,返回对应的顶点下标,否则返回-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (MinDist &lt; INFINITY)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MinV;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单源最短路算法 - 迪杰斯特拉算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Dijkstra</span><span class=\"params\">(MGraph Graph, <span class=\"keyword\">int</span> dist[], <span class=\"keyword\">int</span> path[], Vertex S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0.数组dist[w]为顶点S到任意顶点w的距离(权重和),</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组path[w]为到顶点w的最短路径的前驱顶点,</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组collected[w]=true为顶点w找到最短路径</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> collected[MaxVertexNum];</span><br><span class=\"line\">    Vertex V, W;</span><br><span class=\"line\">    <span class=\"comment\">//1.初始化dist[v]为边的权重，path为s或-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (V = <span class=\"number\">0</span>; V &lt; Graph-&gt;Nv; V++) &#123;</span><br><span class=\"line\">        dist[V] = Graph-&gt;G[S][V];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dist[V] &lt; INFINITY)</span><br><span class=\"line\">            path[V] = S;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            path[V] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        collected[V] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.先将起点S收入集合collected，距离dist[s]为0</span></span><br><span class=\"line\">    dist[S] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    collected[S] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3.遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//4.V为未被收录顶点中dist最小者, S到V路径最短</span></span><br><span class=\"line\">        V = FindMinDist(Graph, dist, collected);</span><br><span class=\"line\">        <span class=\"comment\">//5.若这样的V不存在,跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (V == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//6.收录V</span></span><br><span class=\"line\">        collected[V] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//7.遍历图中的每个顶点W</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (W = <span class=\"number\">0</span>; W &lt; Graph-&gt;Nv; W++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//8.若W是V的邻接点并且未被收录</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collected[W] == <span class=\"literal\">false</span> &amp;&amp; Graph-&gt;G[V][W] &lt; INFINITY) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//9.若有负边,不能正确解决，返回错误标记</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Graph-&gt;G[V][W] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 10.若收录V使得dist[W]变小,更新dist[W],更新S到W的路径path[W]</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[V] + Graph-&gt;G[V][W] &lt; dist[W]) &#123;</span><br><span class=\"line\">                    dist[W] = dist[V] + Graph-&gt;G[V][W];</span><br><span class=\"line\">                    path[W] = V;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求两点i,j间的最短距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Floyd</span><span class=\"params\">(MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0.数组D[i][j]为i,j两点间的最短路径,path[i][j]为i,j最短路径,点j的前驱点</span></span><br><span class=\"line\">    Vertex i, j, k;</span><br><span class=\"line\">    <span class=\"comment\">// 1.初始化Vi,Vj的最短路径D为两点间的权重,路径path为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Graph-&gt;Nv; j++) &#123;</span><br><span class=\"line\">            D[i][j] = Graph-&gt;G[i][j];</span><br><span class=\"line\">            path[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.三重遍历，找到任意两点i,j间的最短距离及路径</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (k = <span class=\"number\">0</span>; k &lt; Graph-&gt;Nv; k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Graph-&gt;Nv; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 3.如果找到新的k点，使得ik加kj距离小于原来的值，更新距离和路径</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (D[i][k] + D[k][j] &lt; D[i][j]) &#123;</span><br><span class=\"line\">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class=\"line\">                    <span class=\"comment\">// 4.如果存在负值圈，返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == j &amp;&amp; D[i][j] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    path[i][j] = k;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>注意顶点是从0开始，还是从1开始；遍历时需要注意</li>\n</ol>\n","categories":["数据结构"],"tags":["图","邻接矩阵"]},{"title":"树结构_二叉树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h4 id=\"树结构-二叉树的结构及其操作\"><a href=\"#树结构-二叉树的结构及其操作\" class=\"headerlink\" title=\"树结构 - 二叉树的结构及其操作\"></a>树结构 - 二叉树的结构及其操作</h4><h5 id=\"结构-TNode-PtrToTNode-BinTree\"><a href=\"#结构-TNode-PtrToTNode-BinTree\" class=\"headerlink\" title=\"结构 TNode - PtrToTNode - BinTree\"></a>结构 TNode - PtrToTNode - BinTree</h5><ol>\n<li>结点数据Data</li>\n<li>当前结点的左子树</li>\n<li>当前结点的右子树</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请树TNode空间</li>\n<li>初始化树的左、右孩子为NULL</li>\n</ol>\n<h5 id=\"先序遍历-根-左-右\"><a href=\"#先序遍历-根-左-右\" class=\"headerlink\" title=\"先序遍历 (根 - 左 - 右)\"></a>先序遍历 (根 - 左 - 右)</h5><ol>\n<li>如果树不为空</li>\n<li>访问当前树的数据</li>\n<li>一路递归向左子树走</li>\n<li>再转身树的右子树递归</li>\n</ol>\n<h5 id=\"中序遍历-左-根-右\"><a href=\"#中序遍历-左-根-右\" class=\"headerlink\" title=\"中序遍历 (左 - 根 - 右)\"></a>中序遍历 (左 - 根 - 右)</h5><ol>\n<li>如果树不为空</li>\n<li>一路递归向左子树走</li>\n<li>访问当前树的数据</li>\n<li>再转身树的右子树递归</li>\n</ol>\n<h5 id=\"后序遍历-左-右-根\"><a href=\"#后序遍历-左-右-根\" class=\"headerlink\" title=\"后序遍历 (左 - 右 - 根)\"></a>后序遍历 (左 - 右 - 根)</h5><ol>\n<li>如果树不为空</li>\n<li>一路递归向左子树走</li>\n<li>再转身树的右子树递归</li>\n<li>访问当前树的数据</li>\n</ol>\n<h5 id=\"非递归遍历-堆栈实现中序遍历\"><a href=\"#非递归遍历-堆栈实现中序遍历\" class=\"headerlink\" title=\"非递归遍历 - 堆栈实现中序遍历\"></a>非递归遍历 - 堆栈实现中序遍历</h5><ol>\n<li>创建堆栈S</li>\n<li>树T不为空，或栈S不为空，就一直循环</li>\n<li>遍历左子树，并将沿途结点压入栈</li>\n<li>将最深层的左树结点从堆栈中弹出T，并访问</li>\n<li>转向访问该结点T的右子树</li>\n</ol>\n<h5 id=\"非递归遍历-层序遍历\"><a href=\"#非递归遍历-层序遍历\" class=\"headerlink\" title=\"非递归遍历 - 层序遍历\"></a>非递归遍历 - 层序遍历</h5><ol>\n<li>判空BT</li>\n<li>创建空队列</li>\n<li>将根结点加到队列中</li>\n<li>遍历队列Q至空</li>\n<li>从队列中取出一个元素结点，访问打印</li>\n<li>如果结点左子树不为空，将结点的左子树添加到队列中</li>\n<li>如果结点右子树不为空，将结点的右子树添加到队列中</li>\n</ol>\n<h5 id=\"求所有叶子结点（基于先序遍历）\"><a href=\"#求所有叶子结点（基于先序遍历）\" class=\"headerlink\" title=\"求所有叶子结点（基于先序遍历）\"></a>求所有叶子结点（基于先序遍历）</h5><ol>\n<li>如果二叉树不为空</li>\n<li>判断是否有子孩子,无则是叶子结点</li>\n<li>递归向左子树</li>\n<li>递归向右子树</li>\n</ol>\n<h5 id=\"求二叉树的高度\"><a href=\"#求二叉树的高度\" class=\"headerlink\" title=\"求二叉树的高度\"></a>求二叉树的高度</h5><ol>\n<li>判空NULL</li>\n<li>递归求左子树的高度HL</li>\n<li>递归求右子树的高度HR</li>\n<li>返回较大者MaxH，+1指包含当前层</li>\n</ol>\n<h5 id=\"根据层序遍历生成二叉树\"><a href=\"#根据层序遍历生成二叉树\" class=\"headerlink\" title=\"根据层序遍历生成二叉树\"></a>根据层序遍历生成二叉树</h5><ol>\n<li>创建队列Q</li>\n<li>读入根结点数据</li>\n<li>动态申请空结点BT，赋值给结点并初始化左右子树为NULL</li>\n<li>将根结点BT加入队列</li>\n<li>如果队列不为空，遍历队列</li>\n<li>Q出列得到T</li>\n<li>读取左子树数据</li>\n<li>如果输入的数据不为空，则插入T的左子树，并加入队列Q</li>\n<li>读取右子树数据</li>\n<li>如果输入的数据不为空，则插入T的右子树，并加入队列Q</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NoInfo 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> *<span class=\"title\">PtrToTNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToTNode BinTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树的链表表示 5(遍历)+2(叶子和高度)+1(创建)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.当前结点的左子树</span></span><br><span class=\"line\">    PtrToTNode Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.当前结点的右子树</span></span><br><span class=\"line\">    PtrToTNode Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> BT == <span class=\"literal\">NULL</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 二叉遍历，有先序遍历、中序遍历、后序遍历、堆栈遍历、层次遍历</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">CreatBinTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   BinTree BT;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请树TNode空间</span></span><br><span class=\"line\">   BT = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.初始化树的左、右孩子为NULL</span></span><br><span class=\"line\">   BT-&gt;Left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   BT-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> BT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中序遍历 左-根-右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.一路递归向左子树走</span></span><br><span class=\"line\">       InOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 4.再转身树的右子树递归</span></span><br><span class=\"line\">       InOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先序遍历 根-左-右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 3.一路递归向左子树走</span></span><br><span class=\"line\">       PreOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 4.再转身树的右子树递归</span></span><br><span class=\"line\">       PreOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后序遍历，左-右-根</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果树不为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.一路递归向左子树走</span></span><br><span class=\"line\">       PostOrderTraversal(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.再转身树的右子树递归</span></span><br><span class=\"line\">       PostOrderTraversal(BT-&gt;Right);</span><br><span class=\"line\">       <span class=\"comment\">// 4.访问当前树的数据</span></span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非递归遍历 - 堆栈实现中序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderTraversalStack</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   BinTree  T;</span><br><span class=\"line\">   <span class=\"comment\">// 1.创建堆栈</span></span><br><span class=\"line\">   Stack S = CreateStack();</span><br><span class=\"line\">   T = BT;</span><br><span class=\"line\">   <span class=\"comment\">// 2.树T不为空，或栈S不为空，就一直循环</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (T || !IsEmpty(S))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 3.遍历左子树，并将沿途结点压入栈</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> (T)&#123;</span><br><span class=\"line\">           Push(S, T);</span><br><span class=\"line\">           T = T-&gt;Left;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 4.将最深层的左树结点从堆栈中弹出T，并访问</span></span><br><span class=\"line\">       T = Pop(S);</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 5.转向访问该结点T的右子树</span></span><br><span class=\"line\">       T = T-&gt;Right;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非递归遍历 - 层序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrderTraversal</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   Queue Q;</span><br><span class=\"line\">   BinTree  T;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判空BT</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!BT)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.创建空队列</span></span><br><span class=\"line\">   Q = CreateQueue();</span><br><span class=\"line\">   <span class=\"comment\">// 3.将根结点加到队列中</span></span><br><span class=\"line\">   AddQ(Q, BT);</span><br><span class=\"line\">   <span class=\"comment\">// 4.遍历队列Q至空</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (!IsEmpty(Q))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 5.从队列中取出一个元素结点，访问打印</span></span><br><span class=\"line\">       T = Delete(Q);</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class=\"line\">       <span class=\"comment\">// 6.如果结点左子树不为空，将结点的左子树添加到队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (T-&gt;Left) &#123;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Left);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 7.如果结点右子树不为空，将结点的右子树添加到队列中</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (T-&gt;Right)&#123;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Right);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求所有叶子结点（基于先序遍历）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrderPrintLeaves</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否有子孩子,无则是叶子结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!BT-&gt;Left &amp;&amp; !BT-&gt;Right) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3.递归向左子树</span></span><br><span class=\"line\">        PreOrderPrintLeaves(BT-&gt;Left);</span><br><span class=\"line\">        <span class=\"comment\">// 4.递归向右子树</span></span><br><span class=\"line\">        PreOrderPrintLeaves(BT-&gt;Right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求二叉树的高度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(BinTree BT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> HL, HR, MaxH;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判空NULL</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (BT) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.递归求左子树的高度HL</span></span><br><span class=\"line\">       HL = GetHeight(BT-&gt;Left);</span><br><span class=\"line\">       <span class=\"comment\">// 3.递归求右子树的高度HR</span></span><br><span class=\"line\">       HR = GetHeight(BT-&gt;Right);</span><br><span class=\"line\">       <span class=\"comment\">// 4.返回较大者MaxH，+1指包含当前层</span></span><br><span class=\"line\">       MaxH = HL &gt; HR ? HL : HR;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> MaxH + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 空树返回0</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据层序遍历生成二叉树</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">CreateBinTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BinTree BT, T;</span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建队列Q</span></span><br><span class=\"line\">   Queue Q = CreateQueue();</span><br><span class=\"line\">   <span class=\"comment\">// 2.读入根结点数据</span></span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (Data != NoInfo) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 3.动态申请空结点BT，赋值给结点并初始化左右子树为NULL</span></span><br><span class=\"line\">       BT = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">       BT-&gt;Data = Data;</span><br><span class=\"line\">       BT-&gt;Left = BT-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 4.将根结点BT加入队列</span></span><br><span class=\"line\">       AddQ(Q, BT);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.如果队列不为空，遍历队列</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> (!IsEmpty(Q))&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 6.Q出列得到T</span></span><br><span class=\"line\">       T = DeleteQ(Q);</span><br><span class=\"line\">       <span class=\"comment\">// 7.读取左子树数据</span></span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Data != NoInfo)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 8.如果输入的数据不为空，则插入T的左子树，并加入队列Q</span></span><br><span class=\"line\">           T-&gt;Left = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">           T-&gt;Left-&gt;Data = Data;</span><br><span class=\"line\">           T-&gt;Left-&gt;Left = T-&gt;Left-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Left);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           T-&gt;Left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 9.读取右子树数据</span></span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Data);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Data != NoInfo)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 10.如果输入的数据不为空，则插入T的右子树，并加入队列Q</span></span><br><span class=\"line\">           T-&gt;Right = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TNode));</span><br><span class=\"line\">           T-&gt;Right-&gt;Data = Data;</span><br><span class=\"line\">           T-&gt;Right-&gt;Left = T-&gt;Right-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">           AddQ(Q, T-&gt;Right);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           T-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_哈夫曼树","url":"/2021/07/25/%E6%A0%91%E7%BB%93%E6%9E%84_%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","content":"<h4 id=\"结构-HTNode-PtrToHTNode-HuffmanTree\"><a href=\"#结构-HTNode-PtrToHTNode-HuffmanTree\" class=\"headerlink\" title=\"结构 HTNode - PtrToHTNode - HuffmanTree\"></a>结构 HTNode - PtrToHTNode - HuffmanTree</h4><ol>\n<li>权重</li>\n<li>左哈夫曼树</li>\n<li>右哈夫曼树</li>\n</ol>\n<a id=\"more\"></a>\n\n<h4 id=\"从最小堆构造哈夫曼树\"><a href=\"#从最小堆构造哈夫曼树\" class=\"headerlink\" title=\"从最小堆构造哈夫曼树\"></a>从最小堆构造哈夫曼树</h4><ol>\n<li>假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</li>\n<li>将H-&gt;Elements[]按权值调整为最小堆</li>\n<li>遍历所有元素</li>\n<li>创建树结点,从小顶堆中最小值为左子树，再从堆取最小值为右子树</li>\n<li>将左子树的权重加右子树的权重为根结点的权重</li>\n<li>重新将新创建的根结点插入回小顶堆中</li>\n</ol>\n<h4 id=\"编码：\"><a href=\"#编码：\" class=\"headerlink\" title=\"编码：\"></a>编码：</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HTNode</span> *<span class=\"title\">HuffmanTree</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HTNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.权重</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Weight;</span><br><span class=\"line\">    <span class=\"comment\">// 2.左哈夫曼树</span></span><br><span class=\"line\">    HuffmanTree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.右哈夫曼树</span></span><br><span class=\"line\">    HuffmanTree Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从最小堆构造哈夫曼树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">HuffmanTree <span class=\"title\">HuffMan</span><span class=\"params\">(MinHeap H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    HuffmanTree T;</span><br><span class=\"line\">    <span class=\"comment\">// 2.将H-&gt;Elements[]按权值调整为最小堆</span></span><br><span class=\"line\">    BuildMinHeap(H);</span><br><span class=\"line\">    <span class=\"comment\">// 3.遍历所有元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; H-&gt;Size; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4.创建树结点,从小顶堆中最小值为左子树，再从堆取最小值为右子树</span></span><br><span class=\"line\">        T = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct HTNode));</span><br><span class=\"line\">        T-&gt;Left = DeleteMin(H);</span><br><span class=\"line\">        T-&gt;Right = DeleteMin(H);</span><br><span class=\"line\">        <span class=\"comment\">// 5.将左子树的权重加右子树的权重为根结点的权重</span></span><br><span class=\"line\">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class=\"line\">        <span class=\"comment\">// 6.重新将新创建的根结点插入回小顶堆中</span></span><br><span class=\"line\">        Insert(H, T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T = DeleteMin(H);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","categories":["数据结构"],"tags":["树","哈夫曼树"]},{"title":"树结构_二叉搜索树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"<h4 id=\"二叉搜索树的结构与其操作\"><a href=\"#二叉搜索树的结构与其操作\" class=\"headerlink\" title=\"二叉搜索树的结构与其操作\"></a>二叉搜索树的结构与其操作</h4><h5 id=\"结构-BinNode-BinTree-Position\"><a href=\"#结构-BinNode-BinTree-Position\" class=\"headerlink\" title=\"结构 BinNode - BinTree - Position\"></a>结构 BinNode - BinTree - Position</h5><ol>\n<li>树结点数据Data</li>\n<li>左子树Left</li>\n<li>右子树Right</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"查找-递归\"><a href=\"#查找-递归\" class=\"headerlink\" title=\"查找 - 递归\"></a>查找 - 递归</h5><ol>\n<li>判空BST</li>\n<li>如果元素X大于结点数据，向右递归</li>\n<li>如果元素X小于结点数据，向左递归</li>\n<li>如果相等，直接返回</li>\n</ol>\n<h5 id=\"查找-非递归\"><a href=\"#查找-非递归\" class=\"headerlink\" title=\"查找 - 非递归\"></a>查找 - 非递归</h5><ol>\n<li>循环遍历二叉树BST</li>\n<li>如果结点数据大于元素X，BST指向左子树</li>\n<li>如果结点数据小于元素X，BST指向右子树</li>\n<li>如果相等，跳出并返回BST</li>\n</ol>\n<h5 id=\"找最小值\"><a href=\"#找最小值\" class=\"headerlink\" title=\"找最小值\"></a>找最小值</h5><ol>\n<li>如果二叉树BST不为空</li>\n<li>树BST的左子树不为空则一直向左查找，直到最左树</li>\n</ol>\n<h5 id=\"找最大值\"><a href=\"#找最大值\" class=\"headerlink\" title=\"找最大值\"></a>找最大值</h5><ol>\n<li>如果二叉树BST不为空</li>\n<li>树BST的右子树不为空则一直向右查找，直到最右树</li>\n</ol>\n<h5 id=\"插入结点\"><a href=\"#插入结点\" class=\"headerlink\" title=\"插入结点\"></a>插入结点</h5><ol>\n<li>如果BST树为空，说明找到插入位置，</li>\n<li>为BST申请结点空间，将插入值X赋值给结点，并初始化左、右子树为NULL</li>\n<li>如果插入值X小于结点元素，递归向左子树插入</li>\n<li>如果插入值X大于结点元素，递归向右子树插入</li>\n</ol>\n<h5 id=\"删除结点\"><a href=\"#删除结点\" class=\"headerlink\" title=\"删除结点\"></a>删除结点</h5><ol>\n<li>判断树BST是否为空</li>\n<li>如果待删元素X小于结点值，递归向左删除元素</li>\n<li>如果待删元素X大于结点值，递归向右删除元素</li>\n<li>找到了要删除的元素,且该元素有两个孩子</li>\n<li>从左子树中找到最大子树填充删除结点，或是从右子树中找到最小子树填充</li>\n<li>将找到的最大结点或最小结点的值覆盖到当前待结点</li>\n<li>从右子树中删除最小元素结点，或是在左子树中删除最大元素结点</li>\n<li>如果只有右孩子或无结点, 当前结点被右子树覆盖</li>\n<li>如果只有左孩子，当前结点被左子树覆盖</li>\n<li>释放当前结点</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinNode</span> *<span class=\"title\">BinTree</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二叉搜索树结构</span></span><br><span class=\"line\"><span class=\"comment\"> * 查找+找大+找小+插入+删除（递归+循环）5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.树结点数据</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.左子树</span></span><br><span class=\"line\">    BinTree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.右子树</span></span><br><span class=\"line\">    BinTree Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> BinTree Position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找 - 递归</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">Find</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果元素X大于结点数据，向右递归</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">        Find(BST-&gt;Left, X);</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果元素X小于结点数据，向左递归</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">        Find(BST-&gt;Right, X);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.如果相等，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找 - 非递归</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindX</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.循环遍历二叉树BST</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果结点数据大于元素X，BST指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Left;</span><br><span class=\"line\">            <span class=\"comment\">//3.如果结点数据小于元素X，BST指向右子树</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Right;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//4.如果相等，跳出并返回BST</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找最小值</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindMin</span><span class=\"params\">(BinTree BST)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树BST不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.树BST的左子树不为空则一直向左查找，直到最左树</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (BST-&gt;Left) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找最大值</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindMax</span><span class=\"params\">(BinTree BST)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果二叉树BST不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.树BST的右子树不为空则一直向右查找，直到最右树</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (BST-&gt;Right) &#123;</span><br><span class=\"line\">            BST = BST-&gt;Right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入结点</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">Insert</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.如果BST树为空，说明找到插入位置，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.为BST申请结点空间，将插入值X赋值给结点，并初始化左、右子树为NULL</span></span><br><span class=\"line\">        BST = (BinTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct BinNode));</span><br><span class=\"line\">        BST-&gt;Data = X;</span><br><span class=\"line\">        BST-&gt;Left = BST-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.如果插入值X小于结点元素，递归向左子树插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BST-&gt;Data &gt; X) &#123;</span><br><span class=\"line\">            BST-&gt;Left = Insert(BST-&gt;Left, X);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (BST-&gt;Data &lt; X) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.如果插入值X大于结点元素，递归向右子树插入</span></span><br><span class=\"line\">            BST-&gt;Right = Insert(BST-&gt;Right, X);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除结点</span></span><br><span class=\"line\"><span class=\"function\">BinTree <span class=\"title\">Delete</span><span class=\"params\">(BinTree BST, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position Tmp;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断树BST是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!BST) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Not Found\\n&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.如果待删元素X小于结点值，递归向左删除元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (X &lt; BST-&gt;Data) &#123;</span><br><span class=\"line\">            BST-&gt;Left = Delete(BST-&gt;Left, X);</span><br><span class=\"line\">            <span class=\"comment\">// 3.如果待删元素X大于结点值，递归向右删除元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &gt; BST-&gt;Data) &#123;</span><br><span class=\"line\">            BST-&gt;Right = Delete(BST-&gt;Right, X);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4.找到了要删除的元素,且该元素有两个孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 分两步走，先删替换该结点(有2子)的值，再删除右最小或左最大的结点</span></span><br><span class=\"line\">                <span class=\"comment\">// 5.从左子树中找到最大子树填充删除结点，或是从右子树中找到最小子树填充</span></span><br><span class=\"line\">                Tmp = FindMin(BST-&gt;Right);</span><br><span class=\"line\">                <span class=\"comment\">// 6.将找到的最大结点或最小结点的值覆盖到当前待结点</span></span><br><span class=\"line\">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class=\"line\">                <span class=\"comment\">// 7.从右子树中删除最小元素结点，或是在左子树中删除最大元素结点</span></span><br><span class=\"line\">                BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Tmp = BST;</span><br><span class=\"line\">                <span class=\"comment\">// 8.如果只有右孩子或无结点, 当前结点被右子树覆盖</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!BST-&gt;Left) &#123;</span><br><span class=\"line\">                    BST = BST-&gt;Right;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 9.如果只有左孩子，当前结点被左子树覆盖</span></span><br><span class=\"line\">                    BST = BST-&gt;Left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 10.释放当前结点</span></span><br><span class=\"line\">                <span class=\"built_in\">free</span>(Tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_大顶堆","url":"/2021/07/24/%E6%A0%91%E7%BB%93%E6%9E%84_%E5%A4%A7%E9%A1%B6%E5%A0%86/","content":"<h4 id=\"树结构-大顶堆结构及其操作\"><a href=\"#树结构-大顶堆结构及其操作\" class=\"headerlink\" title=\"树结构 - 大顶堆结构及其操作\"></a>树结构 - 大顶堆结构及其操作</h4><h5 id=\"结构-HeapStruct-MaxHeap\"><a href=\"#结构-HeapStruct-MaxHeap\" class=\"headerlink\" title=\"结构 HeapStruct - MaxHeap\"></a>结构 HeapStruct - MaxHeap</h5><ol>\n<li>存放结点数据的数组Elements，从1位置开始存，0位置放哨兵</li>\n<li>数组元素个数Size</li>\n<li>数组最大容量Capacity</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请堆空间</li>\n<li>动态申请堆的数组空间大小为MaxSize</li>\n<li>初始化大小及容量</li>\n<li>在堆的数组第0个元素存入哨兵，最大或最小值</li>\n</ol>\n<h5 id=\"堆是否为空\"><a href=\"#堆是否为空\" class=\"headerlink\" title=\"堆是否为空\"></a>堆是否为空</h5><ol>\n<li>判断堆的size是否为0</li>\n</ol>\n<h5 id=\"堆是否已满\"><a href=\"#堆是否已满\" class=\"headerlink\" title=\"堆是否已满\"></a>堆是否已满</h5><ol>\n<li>判断堆的size是否等于堆的容量</li>\n</ol>\n<h5 id=\"将元素item插入堆\"><a href=\"#将元素item插入堆\" class=\"headerlink\" title=\"将元素item插入堆\"></a>将元素item插入堆</h5><ol>\n<li>判断堆是已满</li>\n<li>找到堆数组的最后位置++H-&gt;Size</li>\n<li>遍历数组最末位元素结点至根结点，与插入值item比较，直到item小于父结点</li>\n<li>如果插入的元素item大于它的父结点，则需要换位，并找到新插入点的合适位置</li>\n<li>遍历结束找到新结点item有位置i</li>\n</ol>\n<h5 id=\"删除堆的根结点，最大元素\"><a href=\"#删除堆的根结点，最大元素\" class=\"headerlink\" title=\"删除堆的根结点，最大元素\"></a>删除堆的根结点，最大元素</h5><ol>\n<li>判断堆是否为空</li>\n<li>找到堆的最大元素即根结点</li>\n<li>将堆数组最末位元素Temp拎出增补空缺</li>\n<li>遍历整个堆p*2&lt;size,找到最末位结点的新位置</li>\n<li>比较左、右子树的大小，取较大者</li>\n<li>如果最末位元素Temp大于左、右子树，则不处理，否则左、右子树较大者覆盖父结点</li>\n<li>遍历结束，找到Temp位置parent，插入元素</li>\n</ol>\n<h5 id=\"下滤：将H-gt-Element-P-为根的子堆调整为最大堆\"><a href=\"#下滤：将H-gt-Element-P-为根的子堆调整为最大堆\" class=\"headerlink\" title=\"下滤：将H-&gt;Element[P]为根的子堆调整为最大堆\"></a>下滤：将H-&gt;Element[P]为根的子堆调整为最大堆</h5><ol>\n<li>找到位置P对应的值X</li>\n<li>遍历以P为根结点的整棵树</li>\n<li>取结点左、右子树较大者</li>\n<li>如果父结点X的值比子结点大，不处理，否则父子换位</li>\n<li>遍历结束，找到P对应的位置Parent，插入原来的根结点值</li>\n</ol>\n<h5 id=\"将完全二叉树调整为最大堆\"><a href=\"#将完全二叉树调整为最大堆\" class=\"headerlink\" title=\"将完全二叉树调整为最大堆\"></a>将完全二叉树调整为最大堆</h5><ol>\n<li>从最后一个有子孩子的结点(size/2)向前进行下滤</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXDATA 1000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">MaxHeap</span>;</span><span class=\"comment\">// 大顶堆</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//1.存放结点数据的数组，从1位置开始存，0位置放哨兵</span></span><br><span class=\"line\">    ElementType *Elements;</span><br><span class=\"line\">    <span class=\"comment\">// 2.数组元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Size;</span><br><span class=\"line\">    <span class=\"comment\">// 3.数组最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Capacity;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(MaxHeap H)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(MaxHeap H)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">MaxHeap <span class=\"title\">Create</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请堆空间</span></span><br><span class=\"line\">   MaxHeap H = (MaxHeap) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct HeapStruct));</span><br><span class=\"line\">   <span class=\"comment\">// 2.动态申请堆的数组空间大小为MaxSize</span></span><br><span class=\"line\">   H-&gt;Elements = (ElementType) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType) * MaxSize);</span><br><span class=\"line\">   <span class=\"comment\">// 3.初始化大小及容量</span></span><br><span class=\"line\">   H-&gt;Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">   H-&gt;Capacity = MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 4.在堆的数组第0个元素存入哨兵，最大或最小值</span></span><br><span class=\"line\">   H-&gt;Elements[<span class=\"number\">0</span>] = MAXDATA; <span class=\"comment\">//建立哨兵</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断堆的size是否为0</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H-&gt;Size == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsFull</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断堆的size是否等于堆的容量</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> H-&gt;Size == H-&gt;Capacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将元素item插入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(MaxHeap H, ElementType item)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断堆是已满</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsFull(H)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大堆已满&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到堆数组的最后位置++H-&gt;Size</span></span><br><span class=\"line\">   i = ++H-&gt;Size; <span class=\"comment\">// 新插入的元素加在堆的最后一个位置</span></span><br><span class=\"line\">   <span class=\"comment\">// H-&gt;Element[0]为最大元素，为哨兵结点，H-&gt;Elements[i / 2] &lt; item可控制循环结点</span></span><br><span class=\"line\">   <span class=\"comment\">// 3.遍历数组最末位元素结点至根结点，与插入值item比较，直到item小于父结点</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (; H-&gt;Elements[i / <span class=\"number\">2</span>] &lt; item; i /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 4.如果插入的元素item大于它的父结点，则需要换位，并找到新插入点的合适位置</span></span><br><span class=\"line\">       H-&gt;Elements[i] = H-&gt;Elements[i / <span class=\"number\">2</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.遍历结束找到新结点item有位置i</span></span><br><span class=\"line\">   H-&gt;Elements[i] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 删除堆中的最大元素，即根结点</span></span><br><span class=\"line\"><span class=\"comment\">* 每层比较 根结点 左+右子结点，以及最后一个元素结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">DeleteMax</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">   ElementType MaxItem, Temp;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> Parent, Child;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断堆是否为空</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (IsEmpty(H)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大堆为空&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到堆的最大元素即根结点</span></span><br><span class=\"line\">   MaxItem = H-&gt;Elements[<span class=\"number\">1</span>];</span><br><span class=\"line\">   <span class=\"comment\">// 3.将堆数组最末位元素Temp拎出增补空缺</span></span><br><span class=\"line\">   Temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class=\"line\">   <span class=\"comment\">// 4.遍历整个堆p*2&lt;size,找到最末位结点的新位置</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Parent = <span class=\"number\">1</span>; Parent * <span class=\"number\">2</span> &lt; H-&gt;Size; Parent = Child) &#123;</span><br><span class=\"line\">       Child = Parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 5.比较左、右子树的大小，取较大者</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">           Child++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//6. 如果最末位元素Temp大于左、右子树，则不处理，否则左、右子树较大者覆盖父结点</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Temp &gt; H-&gt;Elements[Child])</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 7.遍历结束，找到Temp位置parent，插入元素</span></span><br><span class=\"line\">   H-&gt;Elements[Parent] = Temp;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> MaxItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 下滤:将H-&gt;Elemets[p]为根的子堆调整为最大堆</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">* @param P</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PercDown</span><span class=\"params\">(MaxHeap H, <span class=\"keyword\">int</span> P)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> Parent, Child;</span><br><span class=\"line\">   ElementType X;</span><br><span class=\"line\">   <span class=\"comment\">// 1.找到位置P对应的值X</span></span><br><span class=\"line\">   X = H-&gt;Elements[P];</span><br><span class=\"line\">   <span class=\"comment\">// 2.遍历以P为根结点的整棵树</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Parent = P; Parent * <span class=\"number\">2</span> &lt;= H-&gt;Size; Parent = Child) &#123;</span><br><span class=\"line\">       Child = Parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 3.取结点左、右子树较大者</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class=\"number\">1</span>]))</span><br><span class=\"line\">           Child++;</span><br><span class=\"line\">           <span class=\"comment\">// 4.如果父结点X的值比子结点大，不处理，否则父子换位</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (X &gt;= H-&gt;Elements[Child])</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 5.遍历结束，找到P对应的位置Parent，插入原来的根结点值</span></span><br><span class=\"line\">   H-&gt;Elements[Parent] = X;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 建立最大堆，并不断地将小的元素下滤</span></span><br><span class=\"line\"><span class=\"comment\">* @param H</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(MaxHeap H)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"comment\">// 1.从最后一个有子孩子的结点(size/2)向前进行下滤</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = H-&gt;Size / <span class=\"number\">2</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">       PercDown(H, i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//验证构建、删除、插入大顶堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> maxNum, i;</span><br><span class=\"line\">   ElementType value;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input the heap numbers:\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;maxNum);</span><br><span class=\"line\">   MaxHeap Heap = Create(maxNum);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input %d numbers:\\n&quot;</span>, maxNum);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; maxNum; i++) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;value);</span><br><span class=\"line\">       Insert(Heap, value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The root value is: %d\\n&quot;</span>, Heap-&gt;Elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"comment\">//    value = DeleteMax(Heap);</span></span><br><span class=\"line\"><span class=\"comment\">// 先注释插入时与根结点的比较,先只构造完全二叉树的结构，最通过下滤构造大顶堆</span></span><br><span class=\"line\">   BuildHeap(Heap);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;after delete, the value is: %d\\n&quot;</span>, Heap-&gt;Elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"树结构_平衡二叉树","url":"/2021/07/22/%E6%A0%91%E7%BB%93%E6%9E%84_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h4 id=\"树结构-平衡二叉树结构及其操作\"><a href=\"#树结构-平衡二叉树结构及其操作\" class=\"headerlink\" title=\"树结构 - 平衡二叉树结构及其操作\"></a>树结构 - 平衡二叉树结构及其操作</h4><h5 id=\"结构-AVLNode-Position-AVLTree\"><a href=\"#结构-AVLNode-Position-AVLTree\" class=\"headerlink\" title=\"结构 AVLNode - Position - AVLTree\"></a>结构 AVLNode - Position - AVLTree</h5><ol>\n<li>结点的数据Data</li>\n<li>结点的左子树</li>\n<li>结点的右子树</li>\n<li>以当前结点为根的树高</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"将X插入平衡树-递归实现\"><a href=\"#将X插入平衡树-递归实现\" class=\"headerlink\" title=\"将X插入平衡树(递归实现)\"></a>将X插入平衡树(递归实现)</h5><ol>\n<li>如果为空则说明找到需要插入的位置</li>\n<li>动态申请新结点AVLNode,将待插值X赋值给新结点T</li>\n<li>初始化左右子树为NULL,树高为1</li>\n<li>如果X比结点元素值小，则向左搜索插入点</li>\n<li>如果平衡因子(左-右)大于等于2，需要左旋</li>\n<li>如果插入点在左子树的左边，则单左旋，在左子树的右边则进行左-右旋</li>\n<li>如果X比结点元素值大，则向右搜索插入点</li>\n<li>如果平衡因子(左-右)大于等于2，需要右旋</li>\n<li>如果插入点在右子树的右边，则单右旋，在右子树的左边则进行右-左旋</li>\n</ol>\n<h5 id=\"左单旋\"><a href=\"#左单旋\" class=\"headerlink\" title=\"左单旋\"></a>左单旋</h5><ol>\n<li>结点A必须有一个左子结点，将A与B做左单旋，更新A与B的高度</li>\n<li>将B的右子树挂在A的左子树上，B不在为A左子树， 如果B有右子树的话</li>\n<li>A作为B的右子树，完成左旋</li>\n<li>重新计算树A,B高度</li>\n<li>B为新的根结点</li>\n</ol>\n<h5 id=\"右单旋\"><a href=\"#右单旋\" class=\"headerlink\" title=\"右单旋\"></a>右单旋</h5><ol>\n<li>A必须有右子树，将A与B右单旋</li>\n<li>将右子树B的左边挂在根结点A的右为，B不再为A的右结点</li>\n<li>将A作为B的左子树</li>\n<li>重新的计算树高度</li>\n<li>B为新的根结点</li>\n</ol>\n<h5 id=\"左-右双旋\"><a href=\"#左-右双旋\" class=\"headerlink\" title=\"左 - 右双旋\"></a>左 - 右双旋</h5><ol>\n<li>先以左子树为根结点右旋转</li>\n<li>后以发现者为根结点左旋转</li>\n</ol>\n<h5 id=\"右-左双旋\"><a href=\"#右-左双旋\" class=\"headerlink\" title=\"右 - 左双旋\"></a>右 - 左双旋</h5><ol>\n<li>先以右子树为根结点进行左旋转</li>\n<li>再以发现者为根结点右旋转</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVLNode</span> *<span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Position AVLTree;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AVLNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.结点的左子树</span></span><br><span class=\"line\">    AVLTree Left;</span><br><span class=\"line\">    <span class=\"comment\">// 3.结点的右子树</span></span><br><span class=\"line\">    AVLTree Right;</span><br><span class=\"line\">    <span class=\"comment\">// 4.以当前结点为根的树高</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(AVLTree AT)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleLeftRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleRightRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleLeftRightRation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleRightLeftRotation</span><span class=\"params\">(AVLTree A)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将X插入到树A中,递归实现</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @param X</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">Insert</span><span class=\"params\">(AVLTree T, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.如果为空则说明找到需要插入的位置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!T) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.动态申请新结点AVLNode,将待插值X赋值给新结点T</span></span><br><span class=\"line\">       T = (AVLTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct AVLNode));</span><br><span class=\"line\">       T-&gt;Data = X;</span><br><span class=\"line\">       <span class=\"comment\">// 3.初始化左右子树为NULL,树高为1</span></span><br><span class=\"line\">       T-&gt;Height = <span class=\"number\">1</span>;</span><br><span class=\"line\">       T-&gt;Left = T-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &lt; T-&gt;Data) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 4.如果X比结点元素值小，则向左搜索插入点</span></span><br><span class=\"line\">       T-&gt;Left = Insert(T-&gt;Left, X);</span><br><span class=\"line\">       <span class=\"comment\">// 5.如果平衡因子(左-右)大于等于2，需要左旋</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 6.如果插入点在左子树的左边，则单左旋，在左子树的右边则进行左-右旋</span></span><br><span class=\"line\">           <span class=\"comment\">// T为发现者</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (X &lt; T-&gt;Left-&gt;Data) &#123;</span><br><span class=\"line\">               T = SingleLeftRotation(T);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               T = DoubleLeftRightRation(T);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (X &gt; T-&gt;Data) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 7.如果X比结点元素值大，则向右搜索插入点</span></span><br><span class=\"line\">       T-&gt;Right = Insert(T-&gt;Right, X);</span><br><span class=\"line\">       <span class=\"comment\">// 8.如果平衡因子(左-右)大于等于2，需要右旋</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 9.如果插入点在右子树的右边，则单右旋，在右子树的左边则进行右-左旋</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (X &gt; T-&gt;Right-&gt;Data) &#123;</span><br><span class=\"line\">               T = SingleRightRotation(T);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               T = DoubleRightLeftRotation(T);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;<span class=\"comment\">/* else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">       X = T-&gt;Data;// 无需要插入</span></span><br><span class=\"line\"><span class=\"comment\">   &#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 左-右双旋</span></span><br><span class=\"line\"><span class=\"comment\">* 破坏结点在发现者的左子树的右子树上，</span></span><br><span class=\"line\"><span class=\"comment\">* 先以左子树为根结点进行右旋转再发现者为根结点进行左旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleLeftRightRation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.先以左子树为根结点右旋转,后以发现者为根结点左旋转</span></span><br><span class=\"line\">   A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> SingleLeftRotation(A);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 右-左双旋</span></span><br><span class=\"line\"><span class=\"comment\">* 破坏者在发现者的右子树的左子树上，</span></span><br><span class=\"line\"><span class=\"comment\">* 先以右子树为根结点进行左旋转，再以发现者为根结点进行右旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">DoubleRightLeftRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.先以右子树为根结点进行左旋转，再以发现者为根结点右旋转</span></span><br><span class=\"line\">   A-&gt;Right = SingleLeftRotation(A-&gt;Right);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> SingleRightRotation(A);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 左单旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleLeftRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.结点A必须有一个左子结点，将A与B做左单旋，更新A与B的高度</span></span><br><span class=\"line\">   AVLTree B = A-&gt;Left;</span><br><span class=\"line\">   <span class=\"comment\">// 2.如果B有右子树的话,将B的右子树挂在A的左子树上，B不在为A左子树</span></span><br><span class=\"line\">   A-&gt;Left = B-&gt;Right;</span><br><span class=\"line\">   <span class=\"comment\">// 3.A作为B的右子树，完成左旋</span></span><br><span class=\"line\">   B-&gt;Right = A;</span><br><span class=\"line\">   <span class=\"comment\">// 4.重新计算树A,B高度</span></span><br><span class=\"line\">   A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   B-&gt;Height = Max(GetHeight(B-&gt;Left), GetHeight(B-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 5.B为新的根结点</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 右单旋转</span></span><br><span class=\"line\"><span class=\"comment\">* @param A</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">AVLTree <span class=\"title\">SingleRightRotation</span><span class=\"params\">(AVLTree A)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.A必须有右子树，将A与B右单旋</span></span><br><span class=\"line\">   AVLTree B = A-&gt;Right;</span><br><span class=\"line\">   <span class=\"comment\">// 2.将右子树B的左边挂在根结点A的右为，B不再为A的右结点</span></span><br><span class=\"line\">   A-&gt;Right = B-&gt;Left;</span><br><span class=\"line\">   <span class=\"comment\">// 3.将A作为B的左子树</span></span><br><span class=\"line\">   B-&gt;Left = A;</span><br><span class=\"line\">   <span class=\"comment\">// 4.重新的计算树高度</span></span><br><span class=\"line\">   A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   B-&gt;Height = Max(GetHeight(B-&gt;Left), GetHeight(B-&gt;Right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 获取平衡二叉树的高度,递归</span></span><br><span class=\"line\"><span class=\"comment\">* @param AT</span></span><br><span class=\"line\"><span class=\"comment\">* @return</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetHeight</span><span class=\"params\">(AVLTree AT)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> HL, HR, Max;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (AT) &#123;</span><br><span class=\"line\">       HL = GetHeight(AT-&gt;Left);</span><br><span class=\"line\">       HR = GetHeight(AT-&gt;Right);</span><br><span class=\"line\">       Max = HL &gt; HR ? HL : HR;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Max + <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["树","二叉树"]},{"title":"数据结构_堆栈","url":"/2021/07/19/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E5%A0%86%E6%A0%88/","content":"<h4 id=\"线性结构-堆栈的顺序存储表示及其操作\"><a href=\"#线性结构-堆栈的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 堆栈的顺序存储表示及其操作\"></a>线性结构 - 堆栈的顺序存储表示及其操作</h4><h5 id=\"结构-SNode-PtrToSNode-Stack\"><a href=\"#结构-SNode-PtrToSNode-Stack\" class=\"headerlink\" title=\"结构 SNode - PtrToSNode - Stack\"></a>结构 SNode - PtrToSNode - Stack</h5><ol>\n<li>堆栈中的数组，用于存放数据Data</li>\n<li>栈顶指针Top,可用于判断是否空或满</li>\n<li>栈的最大容量MaxSize</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请栈空间Stack</li>\n<li>初始化Top指针为-1，及最大容量</li>\n<li>动态申请Stack中数组的空间</li>\n</ol>\n<h5 id=\"是否已满\"><a href=\"#是否已满\" class=\"headerlink\" title=\"是否已满\"></a>是否已满</h5><ol>\n<li>栈顶指针Top是否与数组最大容量-1相等</li>\n</ol>\n<h5 id=\"是否为空\"><a href=\"#是否为空\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>判断Top指针是否为-1</li>\n</ol>\n<h5 id=\"压栈\"><a href=\"#压栈\" class=\"headerlink\" title=\"压栈\"></a>压栈</h5><ol>\n<li>先判断是已经满了</li>\n<li>将元素存放到Stack的数组的最后一个空位上</li>\n<li>Stack的Top指针加1</li>\n</ol>\n<h5 id=\"弹栈\"><a href=\"#弹栈\" class=\"headerlink\" title=\"弹栈\"></a>弹栈</h5><ol>\n<li>判断Stack是否为空</li>\n<li>将栈顶元素返回，即Stack中数组的最末位,Top</li>\n<li>栈顶指针Top下移一位，原来的栈顶元素就无法被访问了，可不删除或覆盖</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 堆栈中的数组，用于存放数据</span></span><br><span class=\"line\">    ElementType *Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 栈顶指针,可用于判断是否空或满</span></span><br><span class=\"line\">    Position Top;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 栈的最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToSNode Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Stack <span class=\"title\">CreateStack</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span>&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请栈空间Stack</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化Top指针为-1，及最大容量</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 动态申请Stack中数组的空间</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Data = (ElementType *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType) * MaxSize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶指针Top是否与数组最大容量-1相等</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> result = <span class=\"built_in\">stack</span>-&gt;Top == <span class=\"built_in\">stack</span>-&gt;MaxSize <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断Top指针是否为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Top == <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先判断是已经满了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span>-&gt;Top == <span class=\"built_in\">stack</span>-&gt;MaxSize <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;stack is full&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 将元素存放到Stack的数组的最后一个空位上</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. Stack的Top指针加1</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Data[++(<span class=\"built_in\">stack</span>-&gt;Top)] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹栈</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Pop</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1、判断Stack是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>-&gt;Top == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 将栈顶元素返回，即Stack中数组的最末位,Top</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 栈顶指针Top下移一位，原来的栈顶元素就无法被访问了，可不删除或覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Data[(<span class=\"built_in\">stack</span>-&gt;Top)--];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-堆栈的链式存储表示及其操作\"><a href=\"#线性结构-堆栈的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 堆栈的链式存储表示及其操作\"></a>线性结构 - 堆栈的链式存储表示及其操作</h4><h5 id=\"结构-SNode-PtrToSNode-Stack-1\"><a href=\"#结构-SNode-PtrToSNode-Stack-1\" class=\"headerlink\" title=\"结构 SNode - PtrToSNode - Stack\"></a>结构 SNode - PtrToSNode - Stack</h5><ol>\n<li>结点的数据Data</li>\n<li>下一个结点Next</li>\n</ol>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请Stack空间，并初始化下一个结点Next为NULL</li>\n</ol>\n<h5 id=\"判断是否为空\"><a href=\"#判断是否为空\" class=\"headerlink\" title=\"判断是否为空\"></a>判断是否为空</h5><ol>\n<li>判断头结点的下一个结点是否为NULL</li>\n</ol>\n<h5 id=\"压栈-1\"><a href=\"#压栈-1\" class=\"headerlink\" title=\"压栈\"></a>压栈</h5><ol>\n<li>动态申请新结点的空间，创建新结点node</li>\n<li>将新值item赋值给新结点node</li>\n<li>新结点的下一个结点指向栈的头结点下一个结点（第一个结点）</li>\n<li>头结点的下一个结点(第一个结点)为新结点node，链表头插入头删除</li>\n</ol>\n<h5 id=\"弹栈-1\"><a href=\"#弹栈-1\" class=\"headerlink\" title=\"弹栈\"></a>弹栈</h5><ol>\n<li>判断栈是否为空</li>\n<li>用临时结点firstItem暂存第一个结点，value暂存第一个结点的值</li>\n<li>头结点的下一个结点指向第一个结点的下一个结点(第二个结点)，删除原来的第一个结点</li>\n<li>释放原来的第一个结点firstItem</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span> *<span class=\"title\">PtrToSNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToSNode Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2.下一个结点Next</span></span><br><span class=\"line\">    PtrToSNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Stack <span class=\"title\">CreateStack</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Stack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请Stack空间，并初始化下一个结点Next为NULL</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断栈是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmepty</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断头结点的下一个结点是否为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;Next == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToSNode node;</span><br><span class=\"line\">    <span class=\"comment\">// 1.动态申请新结点的空间，创建新结点node</span></span><br><span class=\"line\">    node = (PtrToSNode)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct SNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2.将新值item赋值给新结点node</span></span><br><span class=\"line\">    node-&gt;Data = item;</span><br><span class=\"line\">    <span class=\"comment\">// 3.新结点的下一个结点指向栈的头结点下一个结点（第一个结点）</span></span><br><span class=\"line\">    node-&gt;Next = <span class=\"built_in\">stack</span>-&gt;Next;</span><br><span class=\"line\">    <span class=\"comment\">// 4.头结点的下一个结点(第一个结点)为新结点node，链表头插入头删除</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹栈</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Pop</span><span class=\"params\">(Stack <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断栈是否为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isEmepty(<span class=\"built_in\">stack</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;stack is empty&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToSNode firstItem;</span><br><span class=\"line\">    ElementType value;</span><br><span class=\"line\">    <span class=\"comment\">// 2.用临时结点firstItem暂存第一个结点，value暂存第一个结点的值</span></span><br><span class=\"line\">    firstItem = <span class=\"built_in\">stack</span>-&gt;Next;</span><br><span class=\"line\">    value = firstItem-&gt;Data;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 头结点的下一个结点指向第一个结点的下一个结点(第二个结点)，删除原来的第一个结点</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;Next = firstItem-&gt;Next;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 释放原来的第一个结点firstItem</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(firstItem);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","堆栈"]},{"title":"数据结构_线性表","url":"/2021/07/19/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E8%A1%A8/","content":"<h4 id=\"线性结构-线性表的顺序存储表示及其操作\"><a href=\"#线性结构-线性表的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 线性表的顺序存储表示及其操作\"></a>线性结构 - 线性表的顺序存储表示及其操作</h4><h5 id=\"结构-LNode-PtrToLNode-List\"><a href=\"#结构-LNode-PtrToLNode-List\" class=\"headerlink\" title=\"结构 LNode - PtrToLNode - List\"></a>结构 LNode - PtrToLNode - List</h5><ol>\n<li>实际存储元素的数组Data[MAXSIZE]</li>\n<li>游标，指向最后一个元素Last</li>\n</ol>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><a id=\"more\"></a>\n\n<ol>\n<li>动态申请大小为一个List的内存,也可以指定其数组的大小</li>\n<li>初始化游标Last为-1</li>\n</ol>\n<h5 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h5><ol>\n<li>遍历数组，直到数组最后一个元素或找到元素X</li>\n<li>如果i大于最后一个元素，表示未找到，否则已找到</li>\n</ol>\n<h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><ol>\n<li>先判断表是否已满</li>\n<li>判断插入的位序是否合法</li>\n<li>循环遍历从末位向后复制，空出第i+1的位置</li>\n<li>将新元素X赋值给i+i，完成插入</li>\n<li>游标Last加1</li>\n</ol>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><ol>\n<li>先判断是删除的位置是否合法</li>\n<li>循环遍历从第i位之后的元素向前移一位，将第i个元素覆盖</li>\n<li>游标Last减1</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Position; <span class=\"comment\">// 位置</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType; <span class=\"comment\">// 元素</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span><span class=\"comment\">// 结构体起始位置</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.实际存储元素的数组</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"comment\">// 2.游标，指向最后一个元素</span></span><br><span class=\"line\">    Position Last; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">List <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List L;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 动态申请大小为一个List的内存,也可以指定其数组的大小</span></span><br><span class=\"line\">    L = (List) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct LNode));</span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化游标Last为-1</span></span><br><span class=\"line\">    L-&gt;Last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">Find</span><span class=\"params\">(List L, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历数组，直到数组最后一个元素或找到元素X</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果i大于最后一个元素，表示未找到，否则已找到</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; L-&gt;Last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Insert</span><span class=\"params\">(List L, ElementType X, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.先判断表是否已满</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;Last == MAXSIZE - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;表满&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.判断插入的位序是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L-&gt;Last + <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位序不合法&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Position j;</span><br><span class=\"line\">    <span class=\"comment\">// 3.循环遍历从末位向后复制，空出第i+1的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = L-&gt;Last; j &gt;= i - <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">        L-&gt;Data[j + <span class=\"number\">1</span>] = L-&gt;Data[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4.将新元素X赋值给i+i，完成插入</span></span><br><span class=\"line\">    L-&gt;Data[i - <span class=\"number\">1</span>] = X;</span><br><span class=\"line\">    <span class=\"comment\">// 5. 游标Last加1</span></span><br><span class=\"line\">    L-&gt;Last++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(List L, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 先判断是删除的位置是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L-&gt;Last) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位序%d不正确&quot;</span>, i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Position j;</span><br><span class=\"line\">    <span class=\"comment\">// 2.循环遍历从第i位之后的元素向前移一位，将第i个元素覆盖</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; j &lt; L-&gt;Last; j++) &#123;</span><br><span class=\"line\">        L-&gt;Data[j] = L-&gt;Data[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 游标Last减1</span></span><br><span class=\"line\">    L-&gt;Last--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-线性表的链式存储表示及其操作\"><a href=\"#线性结构-线性表的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 线性表的链式存储表示及其操作\"></a>线性结构 - 线性表的链式存储表示及其操作</h4><h5 id=\"结构-LNode-PtrToLNode-List-1\"><a href=\"#结构-LNode-PtrToLNode-List-1\" class=\"headerlink\" title=\"结构  LNode - PtrToLNode - List\"></a>结构  LNode - PtrToLNode - List</h5><ol>\n<li>当前结点的数据Data</li>\n<li>下一个结点Next</li>\n</ol>\n<h5 id=\"求表长\"><a href=\"#求表长\" class=\"headerlink\" title=\"求表长\"></a>求表长</h5><ol>\n<li>循环遍历，并累加变量len</li>\n</ol>\n<h5 id=\"查找（按位序）\"><a href=\"#查找（按位序）\" class=\"headerlink\" title=\"查找（按位序）\"></a>查找（按位序）</h5><ol>\n<li>位序从第一个元素开始</li>\n<li>p指向第一个结点</li>\n<li>如果指针到指定的index还没有找到，或是扫描到最后的元素NULL,则退出</li>\n<li>指针指向index位置，同时不为NULL</li>\n</ol>\n<h5 id=\"查找（按元素）\"><a href=\"#查找（按元素）\" class=\"headerlink\" title=\"查找（按元素）\"></a>查找（按元素）</h5><ol>\n<li>p指向第一个结点</li>\n<li>当指针遍历到最后为NULL或是找到元素X，则退出</li>\n<li>如果p不为NULL，表示找到元素，返回p，否则返回NULL</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType; <span class=\"comment\">// 元素</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 当前结点的数据Data</span></span><br><span class=\"line\">    ElementType Data;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 下一个结点Next</span></span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求表长</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">(PtrToLNode L)</span> </span>&#123;</span><br><span class=\"line\">    Position P;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    P = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (P) &#123;</span><br><span class=\"line\">        P = P-&gt;Next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找,按index</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">FindElementByIndex</span><span class=\"params\">(List L, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    Position p;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 位序从第一个元素开始</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. p指向第一个结点</span></span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果指针到指定的index还没有找到，或是扫描到最后的元素NULL,则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt &lt; index &amp;&amp; p) &#123;</span><br><span class=\"line\">        p = p-&gt;Next;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 指针指向index位置，同时不为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt == index &amp;&amp; p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;Data;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找，按元素</span></span><br><span class=\"line\"><span class=\"function\">Position <span class=\"title\">FindElement</span><span class=\"params\">(List L, ElementType X)</span> </span>&#123;</span><br><span class=\"line\">    Position p;</span><br><span class=\"line\">    <span class=\"comment\">// 1. p指向第一个结点</span></span><br><span class=\"line\">    p = L;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 当指针遍历到最后为NULL或是找到元素X，则退出</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; p-&gt;Next != X) &#123;</span><br><span class=\"line\">        p = p-&gt;Next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 如果不为NULL，表示找到元素，返回p，否则返回NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","线性表"]},{"title":"线性结构_队列","url":"/2021/07/20/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97/","content":"<h4 id=\"线性结构-队列的顺序存储表示及其操作\"><a href=\"#线性结构-队列的顺序存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 队列的顺序存储表示及其操作\"></a>线性结构 - 队列的顺序存储表示及其操作</h4><h5 id=\"结构-QNode-PtrToQNode-Queue\"><a href=\"#结构-QNode-PtrToQNode-Queue\" class=\"headerlink\" title=\"结构 QNode - PtrToQNode - Queue\"></a>结构 QNode - PtrToQNode - Queue</h5><ol>\n<li>数组Data存放元素，循环存放实现循环队列</li>\n<li>设置队头front与rear队尾两个指针</li>\n<li>队列的最大容量</li>\n</ol>\n<a id=\"more\"></a>\n\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请队列Queue的空间</li>\n<li>动态申请队列中数组Data的空间,</li>\n<li>最大长度为MaxSize</li>\n<li>初始化队头front与队尾rear指针为0</li>\n</ol>\n<h5 id=\"是否为空\"><a href=\"#是否为空\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>队头front与队尾rear相等，则为空队列</li>\n</ol>\n<h5 id=\"是否已满\"><a href=\"#是否已满\" class=\"headerlink\" title=\"是否已满\"></a>是否已满</h5><ol>\n<li>队尾rear+1模以容量等于队头front，则队列已满</li>\n</ol>\n<h5 id=\"入列-队尾rear\"><a href=\"#入列-队尾rear\" class=\"headerlink\" title=\"入列 - 队尾rear\"></a>入列 - 队尾rear</h5><ol>\n<li>判断队列是否已满</li>\n<li>找到队列尾rear指针，在原指针加1后模以容量，以防在最队尾，重回队头</li>\n<li>在队列的数组Data的第rear个位置插入元素item</li>\n</ol>\n<h5 id=\"出列-队头front\"><a href=\"#出列-队头front\" class=\"headerlink\" title=\"出列 - 队头front\"></a>出列 - 队头front</h5><ol>\n<li>判断队列是否为空</li>\n<li>找到队头指针front,在原有指针上加1模以容量，如果在最末位，则重返数组第1位</li>\n<li>返回队头front指针的元素</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">PtrToQNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.数组Data存放元素，循环存放实现循环队列</span></span><br><span class=\"line\">   ElementType *Data;</span><br><span class=\"line\">   <span class=\"comment\">// 2.设置队头front与rear队尾两个指针</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> front, rear;</span><br><span class=\"line\">   <span class=\"comment\">// 3.队列的最大容量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToQNode Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span>&#123;</span><br><span class=\"line\">   Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请队列Queue的空间</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span> = (Queue)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.动态申请队列中数组Data的空间,</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data = (ElementType *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElementType)*MaxSize);</span><br><span class=\"line\">   <span class=\"comment\">// 3.最大长度为MaxSize</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;MaxSize = MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 4.初始化队头front与队尾rear指针为0</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 队头front与队尾rear相等，则为空队列</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;rear == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否已满</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.队尾rear+1模以容量等于队头front，则队列已满</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize == <span class=\"built_in\">queue</span>-&gt;front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入列 - 队尾rear</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">add</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, ElementType item)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 判断队列是否已满</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isFull(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is full!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到队列尾rear指针，在原指针加1后模以容量，以防在最队尾，重回队头</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;rear = (<span class=\"built_in\">queue</span>-&gt;rear + <span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 3.在队列的数组Data的第rear个位置插入元素item</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;rear] = item;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出列 - 队头front</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Delete</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断队列是否为空</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 2.找到队头指针front,在原有指针上加1模以容量，如果在最末位，则重返数组第1位</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;front = (<span class=\"built_in\">queue</span>-&gt;front +<span class=\"number\">1</span>)%<span class=\"built_in\">queue</span>-&gt;MaxSize;</span><br><span class=\"line\">   <span class=\"comment\">// 3.返回队头front指针的元素</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>-&gt;Data[<span class=\"built_in\">queue</span>-&gt;front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线性结构-队列的链式存储表示及其操作\"><a href=\"#线性结构-队列的链式存储表示及其操作\" class=\"headerlink\" title=\"线性结构 - 队列的链式存储表示及其操作\"></a>线性结构 - 队列的链式存储表示及其操作</h4><h5 id=\"结构-邻结点Node-PtrToNode-Position-头结点QNode-Queue\"><a href=\"#结构-邻结点Node-PtrToNode-Position-头结点QNode-Queue\" class=\"headerlink\" title=\"结构 邻结点Node - PtrToNode - Position 头结点QNode - Queue\"></a>结构 邻结点Node - PtrToNode - Position 头结点QNode - Queue</h5><h6 id=\"链表邻结点Node\"><a href=\"#链表邻结点Node\" class=\"headerlink\" title=\"链表邻结点Node\"></a>链表邻结点Node</h6><ol>\n<li>链表邻结点</li>\n<li>下一个结点Next</li>\n</ol>\n<h6 id=\"队列链表头结点\"><a href=\"#队列链表头结点\" class=\"headerlink\" title=\"队列链表头结点\"></a>队列链表头结点</h6><ol>\n<li>链表队列的头Front、尾结Rear点作为指针</li>\n<li>队列容量、长度</li>\n</ol>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ol>\n<li>动态申请队列Queue空间</li>\n<li>初始化队列队头Front、队尾Rear指针为NULL</li>\n</ol>\n<h5 id=\"是否为空-1\"><a href=\"#是否为空-1\" class=\"headerlink\" title=\"是否为空\"></a>是否为空</h5><ol>\n<li>判断队头指针Front是否为NULL</li>\n</ol>\n<h5 id=\"入列-队尾\"><a href=\"#入列-队尾\" class=\"headerlink\" title=\"入列 - 队尾\"></a>入列 - 队尾</h5><ol>\n<li>动态申请邻结点Node空间</li>\n<li>将新插入的值item赋值给新结点node,并初始化Next为NULL</li>\n<li>如果队列为空，则Front和Rear都指向该结点,否则Rear指向该结点</li>\n</ol>\n<h5 id=\"出列-队头\"><a href=\"#出列-队头\" class=\"headerlink\" title=\"出列 - 队头\"></a>出列 - 队头</h5><ol>\n<li>判断队列是否为空</li>\n<li>根据队头指针找到头结点FrontCell及其数据</li>\n<li>如果队列中只有一个元素，队头Front、队尾Rear指针置为NULL，</li>\n<li>否则将头结点Front指向头结点的下一个结点(第二个结点)</li>\n<li>释放原来的头结点FrontCell</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表邻结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.结点数据Data</span></span><br><span class=\"line\">   ElementType Data;</span><br><span class=\"line\">   <span class=\"comment\">// 2.下一个结点Next</span></span><br><span class=\"line\">   PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列链表头结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.链表队列的头Front、尾结Rear点作为指针</span></span><br><span class=\"line\">   Position Front, Rear;</span><br><span class=\"line\">   <span class=\"comment\">// 2.队列容量、长度</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> MaxSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">Queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"function\">Queue <span class=\"title\">CreateQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   Queue <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请队列Queue空间</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span> = (Queue) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct QNode));</span><br><span class=\"line\">   <span class=\"comment\">// 2.初始化队列队头Front、队尾Rear指针为NULL</span></span><br><span class=\"line\">   <span class=\"built_in\">queue</span>-&gt;Front = <span class=\"built_in\">queue</span>-&gt;Rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 是否为空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.判断队头指针Front是否为NULL</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;Front == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入列 - 队尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>, ElementType item)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   PtrToNode node;</span><br><span class=\"line\">   <span class=\"comment\">// 1.动态申请邻结点Node空间</span></span><br><span class=\"line\">   node = (PtrToNode) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Node));</span><br><span class=\"line\">   <span class=\"comment\">// 2.将新插入的值item赋值给新结点node,并初始化Next为NULL</span></span><br><span class=\"line\">   node-&gt;Data = item;</span><br><span class=\"line\">   node-&gt;Next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 3.如果队列为空，则Front和Rear都指向该结点,否则Rear指向该结点</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Front = node;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Rear = node;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"built_in\">queue</span>-&gt;Rear = node;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出列 - 队头</span></span><br><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Delete</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span> </span>&#123;</span><br><span class=\"line\">   Position FrontCell;</span><br><span class=\"line\">   ElementType FrontElem;</span><br><span class=\"line\">   <span class=\"comment\">// 1.判断队列是否为空</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(Queue <span class=\"built_in\">queue</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isEmpty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;queue is empty!&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 2.根据队头指针找到头结点FrontCell及其数据</span></span><br><span class=\"line\">       FrontCell = <span class=\"built_in\">queue</span>-&gt;Front;</span><br><span class=\"line\">       FrontElem = FrontCell-&gt;Data;</span><br><span class=\"line\">       <span class=\"comment\">// 3.如果队列中只有一个元素，队头Front、队尾Rear指针置为NULL，</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;Front == <span class=\"built_in\">queue</span>-&gt;Rear) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">queue</span>-&gt;Front = <span class=\"built_in\">queue</span>-&gt;Rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 4.否则将头结点Front指向头结点的下一个结点(第二个结点)</span></span><br><span class=\"line\">           <span class=\"built_in\">queue</span>-&gt;Front = FrontCell-&gt;Next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 5.释放原来的头结点FrontCell</span></span><br><span class=\"line\">       <span class=\"built_in\">free</span>(FrontCell);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> FrontElem;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["线性结构","队列"]}]